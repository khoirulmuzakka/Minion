# Parent_directory/setup.py

from setuptools import setup, Extension
from Cython.Build import cythonize
from setuptools.command.build_ext import build_ext as _build_ext
import os
import shutil
import glob
import numpy

# Custom build_ext command to delete .c files after compilation and move compiled files to 'lib' folder
class build_ext(_build_ext):
    def run(self):
        try:
            pyd_files = glob.glob('lib/**/*.pyd', recursive=True)
            for pyd_file in pyd_files:
                os.remove(pyd_file)
            
            # Clean build directory
            if os.path.exists('build'):
                for root, dirs, files in os.walk('build', topdown=False):
                    for name in files:
                        os.remove(os.path.join(root, name))
                    for name in dirs:
                        os.rmdir(os.path.join(root, name))
                os.rmdir('build')
            
            #lib_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'lib/AutoNRA'))
            # Ensure 'lib' directory exists
            if not os.path.exists(lib_dir):
                os.makedirs(lib_dir)
            
            super().run()
            print("Compilation finished.")
            

            # Move the compiled extensions to the lib directory
            for ext in self.extensions:
                ext_path = self.get_ext_fullpath(ext.name)
                target_file = os.path.join(lib_dir, os.path.basename(ext_path))
                shutil.move(ext_path, target_file)
                print(f"Moved {ext_path} to {target_file}")
        
        finally:
            # Clean up: delete the .c files generated by Cython
            for ext in self.extensions:
                pyx_file = ext.sources[0]
                c_file = pyx_file 
                if os.path.exists(c_file):
                    os.remove(c_file)

            for root, dirs, files in os.walk(base_dir):
                for file in files:
                    if file == "__init__.py":
                        src_file = os.path.join(root, file)
                        shutil.copy(src_file, lib_dir)
                        print(f"Copied {src_file} to {lib_dir}")

# Get the directory of this file
base_dir = os.path.join("./src", "pyminion")
lib_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'lib/pyminion'))
# Setup script to compile the extensions, move them to 'lib', and clean up .c files

# Setting a compiler directive to simulate macro definition
compiler_directives = {
    'language_level': 3,
    'c_string_type': 'str',
    'c_string_encoding': 'utf-8'
}

setup(
    name="pyminion",
    ext_modules=cythonize(
        [os.path.join(base_dir, "*.pyx")], 
        compiler_directives=compiler_directives
    ),
    cmdclass={'build_ext': build_ext},
    package_dir={'pyminion': "lib/pyminion"} , 
    include_dirs=[ numpy.get_include(), base_dir],
    install_requires=[
    ]
)
