#include "cec2011.h"

#include <algorithm>
#include <array>
#include <cmath>
#include <limits>
#include <numeric>
#include <stdexcept>
#include <vector>
#include <Eigen/Dense>

#ifdef E
#undef E
#endif

namespace minion {

CEC2011Functions::CEC2011Functions(int function_number, int dimension)
    : CECBase(function_number, dimension) {
    testfunc = &CEC2011::evaluate;
}

namespace {
constexpr double kTwoPi = 2.0 * PI;

constexpr std::array<std::array<double, 4>, 10> kProblem3Coeff = {
    {{{0.002918487, -0.008045787, 0.006749947, -0.001416647}},
     {{9.509977, -35.00994, 42.83329, -17.33333}},
     {{26.82093, -95.56079, 113.0398, -44.29997}},
     {{208.7241, -719.8052, 827.7466, -316.6655}},
     {{1.350005, -6.850027, 12.16671, -6.666689}},
     {{0.01921995, -0.0794532, 0.110566, -0.05033333}},
     {{0.1323596, -0.469255, 0.5539323, -0.2166664}},
     {{7.339981, -25.27328, 29.93329, -11.99999}},
     {{-0.3950534, 1.679353, -1.777829, 0.4974987}},
     {{-2.504665e-05, 0.01005854, -0.01986696, 0.00983347}}}};

template <size_t N, typename Deriv>
void rk4Step(std::array<double, N> &state, double t, double dt, Deriv &&deriv) {
    std::array<double, N> k1{};
    deriv(t, state, k1);

    std::array<double, N> temp{};
    for (size_t j = 0; j < N; ++j) {
        temp[j] = state[j] + 0.5 * dt * k1[j];
    }

    std::array<double, N> k2{};
    deriv(t + 0.5 * dt, temp, k2);
    for (size_t j = 0; j < N; ++j) {
        temp[j] = state[j] + 0.5 * dt * k2[j];
    }

    std::array<double, N> k3{};
    deriv(t + 0.5 * dt, temp, k3);
    for (size_t j = 0; j < N; ++j) {
        temp[j] = state[j] + dt * k3[j];
    }

    std::array<double, N> k4{};
    deriv(t + dt, temp, k4);

    for (size_t j = 0; j < N; ++j) {
        state[j] += dt * (k1[j] + 2.0 * k2[j] + 2.0 * k3[j] + k4[j]) / 6.0;
    }
}

template <size_t N, typename Deriv>
std::array<double, N> rk4Integrate(std::array<double, N> state, double t0, double t1,
                                   int steps, Deriv &&deriv) {
    const double dt = (t1 - t0) / static_cast<double>(steps);
    double t = t0;
    for (int i = 0; i < steps; ++i) {
        rk4Step(state, t, dt, deriv);
        t += dt;
    }
    return state;
}

std::array<double, 10> buildProblem3Rates(double u) {
    const double u2 = u * u;
    const double u3 = u2 * u;
    std::array<double, 10> k{};
    for (size_t row = 0; row < kProblem3Coeff.size(); ++row) {
        const auto &c = kProblem3Coeff[row];
        k[row] = c[0] + c[1] * u + c[2] * u2 + c[3] * u3;
    }
    return k;
}

struct TersoffParams {
    double R1;
    double R2;
    double A;
    double B;
    double lambda1;
    double lambda2;
    double lambda3;
    double c;
    double d;
    double n;
    double gamma;
    double h;
};

const TersoffParams kProblem5Params{3.0,
                                    0.2,
                                    3.2647e+3,
                                    9.5373e+1,
                                    3.2394,
                                    1.3258,
                                    1.3258,
                                    4.8381,
                                    2.0417,
                                    22.956,
                                    0.33675,
                                    0.0};

const TersoffParams kProblem6Params{2.85,
                                    0.15,
                                    1.8308e+3,
                                    4.7118e+2,
                                    2.4799,
                                    1.7322,
                                    1.7322,
                                    1.0039e+05,
                                    1.6218e+01,
                                    7.8734e-01,
                                    1.0999e-06,
                                    -5.9826e-01};

struct LineSpec {
    int from;
    int to;
    double reactance;
    double capacity;
    double cost;
};

constexpr std::array<LineSpec, 7> kBaseLines = {{{1, 2, 0.4, 1.0, 0.0},
                                                 {1, 4, 0.6, 0.8, 0.0},
                                                 {1, 5, 0.2, 1.0, 0.0},
                                                 {2, 3, 0.2, 1.0, 0.0},
                                                 {2, 4, 0.4, 1.0, 0.0},
                                                 {3, 5, 0.2, 1.0, 20.0},
                                                 {6, 2, 0.3, 1.0, 30.0}}};

constexpr std::array<LineSpec, 15> kCandidateLines = {{{1, 2, 0.4, 1.0, 40.0},
                                                       {1, 3, 0.38, 1.0, 38.0},
                                                       {1, 4, 0.6, 0.8, 60.0},
                                                       {1, 5, 0.2, 1.0, 20.0},
                                                       {1, 6, 0.68, 0.7, 68.0},
                                                       {2, 3, 0.2, 1.0, 20.0},
                                                       {2, 4, 0.4, 1.0, 40.0},
                                                       {2, 5, 0.31, 1.0, 31.0},
                                                       {6, 2, 0.3, 1.0, 30.0},
                                                       {3, 4, 0.69, 0.82, 59.0},
                                                       {3, 5, 0.2, 1.0, 20.0},
                                                       {6, 3, 0.48, 1.0, 48.0},
                                                       {4, 5, 0.63, 0.75, 63.0},
                                                       {4, 6, 0.30, 1.0, 30.0},
                                                       {5, 6, 0.61, 0.78, 61.0}}};

struct Problem9Line {
    int from;
    int to;
    double reactance;
    double limit;
};

constexpr std::array<Problem9Line, 41> kProblem9Lines = {{
    {1, 2, 0.0575, 130.0},
    {1, 3, 0.1652, 130.0},
    {2, 4, 0.1737, 65.0},
    {3, 4, 0.0379, 130.0},
    {2, 5, 0.1983, 130.0},
    {2, 6, 0.1763, 65.0},
    {4, 6, 0.0414, 90.0},
    {7, 5, 0.1160, 70.0},
    {6, 7, 0.0820, 130.0},
    {6, 8, 0.0420, 32.0},
    {6, 9, 0.2080, 65.0},
    {6, 10, 0.5560, 32.0},
    {11, 9, 0.2080, 65.0},
    {9, 10, 0.1100, 65.0},
    {4, 12, 0.2560, 65.0},
    {13, 12, 0.1400, 65.0},
    {12, 14, 0.2559, 32.0},
    {12, 15, 0.1304, 32.0},
    {12, 16, 0.1987, 32.0},
    {14, 15, 0.1997, 16.0},
    {16, 17, 0.1923, 16.0},
    {15, 18, 0.2185, 16.0},
    {18, 19, 0.1292, 16.0},
    {20, 19, 0.0680, 32.0},
    {10, 20, 0.2090, 32.0},
    {10, 17, 0.0845, 32.0},
    {10, 21, 0.0749, 32.0},
    {10, 22, 0.1499, 32.0},
    {22, 21, 0.0236, 32.0},
    {15, 23, 0.2020, 16.0},
    {22, 24, 0.1790, 16.0},
    {23, 24, 0.2700, 16.0},
    {25, 24, 0.3292, 16.0},
    {25, 26, 0.3800, 16.0},
    {27, 25, 0.2087, 16.0},
    {28, 27, 0.3960, 65.0},
    {27, 29, 0.4153, 16.0},
    {27, 30, 0.6027, 16.0},
    {29, 30, 0.4533, 16.0},
    {8, 28, 0.2000, 32.0},
    {6, 28, 0.0599, 32.0}
}};

constexpr std::array<int, 6> kProblem9GeneratorBuses = {1, 2, 5, 8, 11, 13};
constexpr std::array<int, 21> kProblem9LoadBuses = {2, 3, 4, 5, 7, 8, 10, 12, 14, 15, 16,
                                                    17, 18, 19, 20, 21, 23, 24, 26, 29, 30};
constexpr std::array<double, 6> kProblem9Pg = {1.659, 0.491, 0.216, 0.228, 0.124, 0.116};
constexpr std::array<double, 21> kProblem9Pd = {0.217, 0.024, 0.076, 0.942, 0.228, 0.300, 0.058,
                                                0.112, 0.062, 0.082, 0.035, 0.090, 0.032, 0.095,
                                                0.022, 0.175, 0.032, 0.087, 0.035, 0.024, 0.106};
constexpr std::array<double, 6> kProblem9Rg = {32.7290, 32.1122, 30.3532, 33.6474, 64.1156, 66.8729};
constexpr std::array<double, 21> kProblem9Rd = {
    7.5449, 10.7964, 10.9944, 11.0402, 11.7990, 15.3803, 42.6800,
    41.4551, 73.1939, 57.0430, 45.5920, 43.6553, 61.8002, 59.6409,
    57.0279, 51.0749, 67.1070, 60.6623, 198.6744, 178.9956, 199.9483};

constexpr std::array<std::array<double, 21>, 6> kProblem9BT = {{
    {0.0, 0.0, 0.0, 0.05, 0.10, 0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.05, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.025},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.15, 0.0, 0.0, 0.0, 0.0, 0.025},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.025, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.025, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
}};

constexpr std::array<double, 126> kProblem9UpperBounds = {
    0.217, 0.024, 0.076, 0.892, 0.128, 0.25, 0.058, 0.112, 0.062, 0.082, 0.035, 0.09, 0.032, 0.095, 0.022, 0.175, 0.032, 0.087, 0.035, 0.024, 0.106,
             0.217, 0.024, 0.026, 0.491, 0.228, 0.3, 0.058, 0.112, 0.062, 0.082, 0.035, 0.09, 0.032, 0.095, 0.022, 0.175, 0.032, 0.087, 0.035, 0.024, 0.106,
             0.216, 0.024, 0.076, 0.216, 0.216, 0.216, 0.058, 0.112, 0.062, 0.082, 0.035, 0.09, 0.032, 0.095, 0.022, 0.175, 0.032, 0.087, 0.035, 0.024, 0.081,
             0.217, 0.024, 0.076, 0.228, 0.228, 0.228, 0.058, 0.112, 0.062, 0.082, 0.035, 0.09, 0.032, 0.095, 0.022, 0.025, 0.032, 0.087, 0.035, 0.024, 0.081,
             0.124, 0.024, 0.076, 0.124, 0.124, 0.124, 0.058, 0.112, 0.062, 0.082, 0.035, 0.065, 0.032, 0.095, 0.022, 0.124, 0.032, 0.087, 0.035, 0.024, 0.106,
             0.116, 0.024, 0.076, 0.116, 0.116, 0.116, 0.058, 0.087, 0.062, 0.082, 0.035, 0.09, 0.032, 0.095, 0.022, 0.116, 0.032, 0.087, 0.035, 0.024, 0.106};
             
constexpr std::array<double, 6> kProblem10LowerBoundsAmplitude = {0.2, 0.2, 0.2, 0.2, 0.2, 0.2};
constexpr std::array<double, 6> kProblem10UpperBoundsAmplitude = {1.0, 1.0, 1.0, 1.0, 1.0, 1.0};
constexpr std::array<double, 6> kProblem10LowerBoundsPhase = {-180.0, -180.0, -180.0, -180.0, -180.0, -180.0};
constexpr std::array<double, 6> kProblem10UpperBoundsPhase = {180.0, 180.0, 180.0, 180.0, 180.0, 180.0};
constexpr std::array<double, 2> kProblem10NullAngles = {50.0, 120.0};
constexpr double kProblem10PhiDesired = 18.0; // degrees
constexpr double kProblem10Spacing = 0.5;

static constexpr double kELD13Data1[13][7] = {
    {0.000000, 680.000000, 0.000280, 8.100000, 550.000000, 300.000000, 0.035000},
    {0.000000, 360.000000, 0.000560, 8.100000, 309.000000, 200.000000, 0.042000},
    {0.000000, 360.000000, 0.000560, 8.100000, 307.000000, 200.000000, 0.042000},
    {60.000000, 180.000000, 0.003240, 7.740000, 240.000000, 150.000000, 0.063000},
    {60.000000, 180.000000, 0.003240, 7.740000, 240.000000, 150.000000, 0.063000},
    {60.000000, 180.000000, 0.003240, 7.740000, 240.000000, 150.000000, 0.063000},
    {60.000000, 180.000000, 0.003240, 7.740000, 240.000000, 150.000000, 0.063000},
    {60.000000, 180.000000, 0.003240, 7.740000, 240.000000, 150.000000, 0.063000},
    {60.000000, 180.000000, 0.003240, 7.740000, 240.000000, 150.000000, 0.063000},
    {40.000000, 120.000000, 0.002840, 8.600000, 126.000000, 100.000000, 0.084000},
    {40.000000, 120.000000, 0.002840, 8.600000, 126.000000, 100.000000, 0.084000},
    {55.000000, 120.000000, 0.002840, 8.600000, 126.000000, 100.000000, 0.084000},
    {55.000000, 120.000000, 0.002840, 8.600000, 126.000000, 100.000000, 0.084000},
};

static constexpr double kELD40Data1[40][7] = {
    {36.000000, 114.000000, 0.006900, 6.730000, 94.705000, 100.000000, 0.084000},
    {36.000000, 114.000000, 0.006900, 6.730000, 94.705000, 100.000000, 0.084000},
    {60.000000, 120.000000, 0.020280, 7.070000, 309.540000, 100.000000, 0.084000},
    {80.000000, 190.000000, 0.009420, 8.180000, 369.030000, 150.000000, 0.063000},
    {47.000000, 97.000000, 0.011400, 5.350000, 148.890000, 120.000000, 0.077000},
    {68.000000, 140.000000, 0.011420, 8.050000, 222.330000, 100.000000, 0.084000},
    {110.000000, 300.000000, 0.003570, 8.030000, 287.710000, 200.000000, 0.042000},
    {135.000000, 300.000000, 0.004920, 6.990000, 391.980000, 200.000000, 0.042000},
    {135.000000, 300.000000, 0.005730, 6.600000, 455.760000, 200.000000, 0.042000},
    {130.000000, 300.000000, 0.006050, 12.900000, 722.820000, 200.000000, 0.042000},
    {94.000000, 375.000000, 0.005150, 12.900000, 635.200000, 200.000000, 0.042000},
    {94.000000, 375.000000, 0.005690, 12.800000, 654.690000, 200.000000, 0.042000},
    {125.000000, 500.000000, 0.004210, 12.500000, 913.400000, 300.000000, 0.035000},
    {125.000000, 500.000000, 0.007520, 8.840000, 1760.400000, 300.000000, 0.035000},
    {125.000000, 500.000000, 0.007080, 9.150000, 1728.300000, 300.000000, 0.035000},
    {125.000000, 500.000000, 0.007080, 9.150000, 1728.300000, 300.000000, 0.035000},
    {220.000000, 500.000000, 0.003130, 7.970000, 647.850000, 300.000000, 0.035000},
    {220.000000, 500.000000, 0.003130, 7.950000, 649.690000, 300.000000, 0.035000},
    {242.000000, 550.000000, 0.003130, 7.970000, 647.830000, 300.000000, 0.035000},
    {242.000000, 550.000000, 0.003130, 7.970000, 647.810000, 300.000000, 0.035000},
    {254.000000, 550.000000, 0.002980, 6.630000, 785.960000, 300.000000, 0.035000},
    {254.000000, 550.000000, 0.002980, 6.630000, 785.960000, 300.000000, 0.035000},
    {254.000000, 550.000000, 0.002840, 6.660000, 794.530000, 300.000000, 0.035000},
    {254.000000, 550.000000, 0.002840, 6.660000, 794.530000, 300.000000, 0.035000},
    {254.000000, 550.000000, 0.002770, 7.100000, 801.320000, 300.000000, 0.035000},
    {254.000000, 550.000000, 0.002770, 7.100000, 801.320000, 300.000000, 0.035000},
    {10.000000, 150.000000, 0.521240, 3.330000, 1055.100000, 120.000000, 0.077000},
    {10.000000, 150.000000, 0.521240, 3.330000, 1055.100000, 120.000000, 0.077000},
    {10.000000, 150.000000, 0.521240, 3.330000, 1055.100000, 120.000000, 0.077000},
    {47.000000, 97.000000, 0.011400, 5.350000, 148.890000, 120.000000, 0.077000},
    {60.000000, 190.000000, 0.001600, 6.430000, 222.920000, 150.000000, 0.063000},
    {60.000000, 190.000000, 0.001600, 6.430000, 222.920000, 150.000000, 0.063000},
    {60.000000, 190.000000, 0.001600, 6.430000, 222.920000, 150.000000, 0.063000},
    {90.000000, 200.000000, 0.000100, 8.950000, 107.870000, 200.000000, 0.042000},
    {90.000000, 200.000000, 0.000100, 8.620000, 116.580000, 200.000000, 0.042000},
    {90.000000, 200.000000, 0.000100, 8.620000, 116.580000, 200.000000, 0.042000},
    {25.000000, 110.000000, 0.016100, 5.880000, 307.450000, 80.000000, 0.098000},
    {25.000000, 110.000000, 0.016100, 5.880000, 307.450000, 80.000000, 0.098000},
    {25.000000, 110.000000, 0.016100, 5.880000, 307.450000, 80.000000, 0.098000},
    {242.000000, 550.000000, 0.003130, 7.970000, 647.830000, 300.000000, 0.035000},
};

static constexpr double kELD140Data1[140][5] = {
    {71.000000, 119.000000, 1220.645000, 61.242000, 0.032888},
    {120.000000, 189.000000, 1315.118000, 41.095000, 0.008280},
    {125.000000, 190.000000, 874.288000, 46.310000, 0.003849},
    {125.000000, 190.000000, 874.288000, 46.310000, 0.003849},
    {90.000000, 190.000000, 1976.469000, 54.242000, 0.042468},
    {90.000000, 190.000000, 1338.087000, 61.215000, 0.014992},
    {280.000000, 490.000000, 1818.299000, 11.791000, 0.007039},
    {280.000000, 490.000000, 1133.978000, 15.055000, 0.003079},
    {260.000000, 496.000000, 1320.636000, 13.226000, 0.005063},
    {260.000000, 496.000000, 1320.636000, 13.226000, 0.005063},
    {260.000000, 496.000000, 1320.636000, 13.226000, 0.005063},
    {260.000000, 496.000000, 1106.539000, 14.498000, 0.003552},
    {260.000000, 506.000000, 1176.504000, 14.651000, 0.003901},
    {260.000000, 509.000000, 1176.504000, 14.651000, 0.003901},
    {260.000000, 506.000000, 1176.504000, 14.651000, 0.003901},
    {260.000000, 505.000000, 1176.504000, 14.651000, 0.003901},
    {260.000000, 506.000000, 1017.406000, 15.669000, 0.002393},
    {260.000000, 506.000000, 1017.406000, 15.669000, 0.002393},
    {260.000000, 505.000000, 1229.131000, 14.656000, 0.003684},
    {260.000000, 505.000000, 1229.131000, 14.656000, 0.003684},
    {260.000000, 505.000000, 1229.131000, 14.656000, 0.003684},
    {260.000000, 505.000000, 1229.131000, 14.656000, 0.003684},
    {260.000000, 505.000000, 1267.894000, 14.378000, 0.004004},
    {260.000000, 505.000000, 1229.131000, 14.656000, 0.003684},
    {280.000000, 537.000000, 975.926000, 16.261000, 0.001619},
    {280.000000, 537.000000, 1532.093000, 13.362000, 0.005093},
    {280.000000, 549.000000, 641.989000, 17.203000, 0.000993},
    {280.000000, 549.000000, 641.989000, 17.203000, 0.000993},
    {260.000000, 501.000000, 911.533000, 15.274000, 0.002473},
    {260.000000, 501.000000, 910.533000, 15.212000, 0.002547},
    {260.000000, 506.000000, 1074.810000, 15.033000, 0.003542},
    {260.000000, 506.000000, 1074.810000, 15.033000, 0.003542},
    {260.000000, 506.000000, 1074.810000, 15.033000, 0.003542},
    {260.000000, 506.000000, 1074.810000, 15.033000, 0.003542},
    {260.000000, 500.000000, 1278.460000, 13.992000, 0.003132},
    {260.000000, 500.000000, 861.742000, 15.679000, 0.001323},
    {120.000000, 241.000000, 408.834000, 16.542000, 0.002950},
    {120.000000, 241.000000, 408.834000, 16.542000, 0.002950},
    {423.000000, 774.000000, 1288.815000, 16.518000, 0.000991},
    {423.000000, 769.000000, 1436.251000, 15.815000, 0.001581},
    {3.000000, 19.000000, 699.988000, 75.464000, 0.902360},
    {3.000000, 28.000000, 134.544000, 129.544000, 0.110295},
    {160.000000, 250.000000, 3427.912000, 56.613000, 0.024493},
    {160.000000, 250.000000, 3751.772000, 54.451000, 0.029156},
    {160.000000, 250.000000, 3918.780000, 54.736000, 0.024667},
    {160.000000, 250.000000, 3379.580000, 58.034000, 0.016517},
    {160.000000, 250.000000, 3345.296000, 55.981000, 0.026584},
    {160.000000, 250.000000, 3138.754000, 61.520000, 0.007540},
    {160.000000, 250.000000, 3453.050000, 58.635000, 0.016430},
    {160.000000, 250.000000, 5119.300000, 44.647000, 0.045934},
    {165.000000, 504.000000, 1898.415000, 71.584000, 0.000044},
    {165.000000, 504.000000, 1898.415000, 71.584000, 0.000044},
    {165.000000, 504.000000, 1898.415000, 71.584000, 0.000044},
    {165.000000, 504.000000, 1898.415000, 71.584000, 0.000044},
    {180.000000, 471.000000, 2473.390000, 85.120000, 0.002528},
    {180.000000, 561.000000, 2781.705000, 87.682000, 0.000131},
    {103.000000, 341.000000, 5515.508000, 69.532000, 0.010372},
    {198.000000, 617.000000, 3478.300000, 78.339000, 0.007627},
    {100.000000, 312.000000, 6240.909000, 58.172000, 0.012464},
    {153.000000, 471.000000, 9960.110000, 46.636000, 0.039441},
    {163.000000, 500.000000, 3671.997000, 76.947000, 0.007278},
    {95.000000, 302.000000, 1837.383000, 80.761000, 0.000044},
    {160.000000, 511.000000, 3108.395000, 70.136000, 0.000044},
    {160.000000, 511.000000, 3108.395000, 70.136000, 0.000044},
    {196.000000, 490.000000, 7095.484000, 49.840000, 0.018827},
    {196.000000, 490.000000, 3392.732000, 65.404000, 0.010852},
    {196.000000, 490.000000, 7095.484000, 49.840000, 0.018827},
    {196.000000, 490.000000, 7095.484000, 49.840000, 0.018827},
    {130.000000, 432.000000, 4288.320000, 66.465000, 0.034560},
    {130.000000, 432.000000, 13813.001000, 22.941000, 0.081540},
    {137.000000, 455.000000, 4435.493000, 64.314000, 0.023534},
    {137.000000, 455.000000, 9750.750000, 45.017000, 0.035475},
    {195.000000, 541.000000, 1042.366000, 70.644000, 0.000915},
    {175.000000, 536.000000, 1159.895000, 70.959000, 0.000044},
    {175.000000, 540.000000, 1159.895000, 70.959000, 0.000044},
    {175.000000, 538.000000, 1303.990000, 70.302000, 0.001307},
    {175.000000, 540.000000, 1156.193000, 70.662000, 0.000392},
    {330.000000, 574.000000, 2118.968000, 71.101000, 0.000087},
    {160.000000, 531.000000, 779.519000, 37.854000, 0.000521},
    {160.000000, 531.000000, 829.888000, 37.768000, 0.000498},
    {200.000000, 542.000000, 2333.690000, 67.983000, 0.001046},
    {56.000000, 132.000000, 2028.954000, 77.838000, 0.132050},
    {115.000000, 245.000000, 4412.017000, 63.671000, 0.096968},
    {115.000000, 245.000000, 2982.219000, 79.458000, 0.054868},
    {115.000000, 245.000000, 2982.219000, 79.458000, 0.054868},
    {207.000000, 307.000000, 3174.939000, 93.966000, 0.014382},
    {207.000000, 307.000000, 3218.359000, 94.723000, 0.013161},
    {175.000000, 345.000000, 3723.822000, 66.919000, 0.016033},
    {175.000000, 345.000000, 3551.405000, 68.185000, 0.013653},
    {175.000000, 345.000000, 4332.615000, 60.821000, 0.028148},
    {175.000000, 345.000000, 3493.739000, 68.551000, 0.013470},
    {360.000000, 580.000000, 226.799000, 2.842000, 0.000064},
    {415.000000, 645.000000, 382.932000, 2.946000, 0.000252},
    {795.000000, 984.000000, 156.987000, 3.096000, 0.000022},
    {795.000000, 978.000000, 154.484000, 3.040000, 0.000022},
    {578.000000, 682.000000, 332.834000, 1.709000, 0.000203},
    {615.000000, 720.000000, 326.599000, 1.668000, 0.000198},
    {612.000000, 718.000000, 345.306000, 1.789000, 0.000215},
    {612.000000, 720.000000, 350.372000, 1.815000, 0.000218},
    {758.000000, 964.000000, 370.377000, 2.726000, 0.000193},
    {755.000000, 958.000000, 367.067000, 2.732000, 0.000197},
    {750.000000, 1007.000000, 124.875000, 2.651000, 0.000324},
    {750.000000, 1006.000000, 130.785000, 2.798000, 0.000344},
    {713.000000, 1013.000000, 878.746000, 1.595000, 0.000690},
    {718.000000, 1020.000000, 827.959000, 1.503000, 0.000650},
    {791.000000, 954.000000, 432.007000, 2.425000, 0.000233},
    {786.000000, 952.000000, 445.606000, 2.499000, 0.000239},
    {795.000000, 1006.000000, 467.223000, 2.674000, 0.000261},
    {795.000000, 1013.000000, 475.940000, 2.692000, 0.000259},
    {795.000000, 1021.000000, 899.462000, 1.633000, 0.000707},
    {795.000000, 1015.000000, 1000.367000, 1.816000, 0.000786},
    {94.000000, 203.000000, 1269.132000, 89.830000, 0.014355},
    {94.000000, 203.000000, 1269.132000, 89.830000, 0.014355},
    {94.000000, 203.000000, 1269.132000, 89.830000, 0.014355},
    {244.000000, 379.000000, 4965.124000, 64.125000, 0.030266},
    {244.000000, 379.000000, 4965.124000, 64.125000, 0.030266},
    {244.000000, 379.000000, 4965.124000, 64.125000, 0.030266},
    {95.000000, 190.000000, 2243.185000, 76.129000, 0.024027},
    {95.000000, 189.000000, 2290.381000, 81.805000, 0.001580},
    {116.000000, 194.000000, 1681.533000, 81.140000, 0.022095},
    {175.000000, 321.000000, 6743.302000, 46.665000, 0.076810},
    {2.000000, 19.000000, 394.398000, 78.412000, 0.953443},
    {4.000000, 59.000000, 1243.165000, 112.088000, 0.000044},
    {15.000000, 83.000000, 1454.740000, 90.871000, 0.072468},
    {9.000000, 53.000000, 1011.051000, 97.116000, 0.000448},
    {12.000000, 37.000000, 909.269000, 83.244000, 0.599112},
    {10.000000, 34.000000, 689.378000, 95.665000, 0.244706},
    {112.000000, 373.000000, 1443.792000, 91.202000, 0.000042},
    {4.000000, 20.000000, 535.553000, 104.501000, 0.085145},
    {5.000000, 38.000000, 617.734000, 83.015000, 0.524718},
    {5.000000, 19.000000, 90.966000, 127.795000, 0.176515},
    {50.000000, 98.000000, 974.447000, 77.929000, 0.063414},
    {5.000000, 10.000000, 263.810000, 92.779000, 2.740485},
    {42.000000, 74.000000, 1335.594000, 80.950000, 0.112438},
    {42.000000, 74.000000, 1033.871000, 89.073000, 0.041529},
    {41.000000, 105.000000, 1391.325000, 161.288000, 0.000911},
    {17.000000, 51.000000, 4477.110000, 161.829000, 0.005245},
    {7.000000, 19.000000, 57.794000, 84.972000, 0.234787},
    {7.000000, 19.000000, 57.794000, 84.972000, 0.234787},
    {26.000000, 40.000000, 1258.437000, 16.087000, 1.111878},
};


static constexpr double kELD15Data1[15][5] = {
    {150.000000, 455.000000, 0.000299, 10.100000, 671.000000},
    {150.000000, 455.000000, 0.000183, 10.200000, 574.000000},
    {20.000000, 130.000000, 0.001126, 8.800000, 374.000000},
    {20.000000, 130.000000, 0.001126, 8.800000, 374.000000},
    {150.000000, 470.000000, 0.000205, 10.400000, 461.000000},
    {135.000000, 460.000000, 0.000301, 10.100000, 630.000000},
    {135.000000, 465.000000, 0.000364, 9.800000, 548.000000},
    {60.000000, 300.000000, 0.000338, 11.200000, 227.000000},
    {25.000000, 162.000000, 0.000807, 11.200000, 173.000000},
    {25.000000, 160.000000, 0.001203, 10.700000, 175.000000},
    {20.000000, 80.000000, 0.003586, 10.200000, 186.000000},
    {20.000000, 80.000000, 0.005513, 9.900000, 230.000000},
    {25.000000, 85.000000, 0.000371, 13.100000, 225.000000},
    {15.000000, 55.000000, 0.001929, 12.100000, 309.000000},
    {15.000000, 55.000000, 0.004447, 12.400000, 323.000000},
};

static constexpr double kELD15Data2[15][9] = {
    {400.000000, 80.000000, 120.000000, 150.000000, 150.000000, 150.000000, 150.000000, 150.000000, 150.000000},
    {300.000000, 80.000000, 120.000000, 185.000000, 255.000000, 305.000000, 335.000000, 420.000000, 450.000000},
    {105.000000, 130.000000, 130.000000, 20.000000, 20.000000, 20.000000, 20.000000, 20.000000, 20.000000},
    {100.000000, 130.000000, 130.000000, 20.000000, 20.000000, 20.000000, 20.000000, 20.000000, 20.000000},
    {90.000000, 80.000000, 120.000000, 180.000000, 200.000000, 305.000000, 335.000000, 390.000000, 420.000000},
    {400.000000, 80.000000, 120.000000, 230.000000, 255.000000, 365.000000, 395.000000, 430.000000, 455.000000},
    {350.000000, 80.000000, 120.000000, 135.000000, 135.000000, 135.000000, 135.000000, 135.000000, 135.000000},
    {95.000000, 65.000000, 100.000000, 60.000000, 60.000000, 60.000000, 60.000000, 60.000000, 60.000000},
    {105.000000, 60.000000, 100.000000, 25.000000, 25.000000, 25.000000, 25.000000, 25.000000, 25.000000},
    {110.000000, 60.000000, 100.000000, 25.000000, 25.000000, 25.000000, 25.000000, 25.000000, 25.000000},
    {60.000000, 80.000000, 80.000000, 20.000000, 20.000000, 20.000000, 20.000000, 20.000000, 20.000000},
    {40.000000, 80.000000, 80.000000, 30.000000, 40.000000, 55.000000, 65.000000, 20.000000, 20.000000},
    {30.000000, 80.000000, 80.000000, 25.000000, 25.000000, 25.000000, 25.000000, 25.000000, 25.000000},
    {20.000000, 55.000000, 55.000000, 15.000000, 15.000000, 15.000000, 15.000000, 15.000000, 15.000000},
    {20.000000, 55.000000, 55.000000, 15.000000, 15.000000, 15.000000, 15.000000, 15.000000, 15.000000},
};

static constexpr double kELD15B1[15][15] = {
    {1.4000, 1.2000, 0.7000, -0.1000, -0.3000, -0.1000, -0.1000, -0.1000, -0.3000, -0.5000, -0.3000, -0.2000, 0.4000, 0.3000, -0.1000},
    {1.2000, 1.5000, 1.3000, 0.0000, -0.5000, -0.2000, 0.0000, 0.1000, -0.2000, -0.4000, -0.4000, 0.0000, 0.4000, 1.0000, -0.2000},
    {0.7000, 1.3000, 7.6000, -0.1000, -1.3000, -0.9000, -0.1000, 0.0000, -0.8000, -1.2000, -1.7000, 0.0000, -2.6000, 11.1000, -2.8000},
    {-0.1000, 0.0000, -0.1000, 3.4000, -0.7000, -0.4000, 1.1000, 5.0000, 2.9000, 3.2000, -1.1000, 0.0000, 0.1000, 0.1000, -2.6000},
    {-0.3000, -0.5000, -1.3000, -0.7000, 9.0000, 1.4000, -0.3000, -1.2000, -1.0000, -1.3000, 0.7000, -0.2000, -0.2000, -2.4000, -0.3000},
    {-0.1000, -0.2000, -0.9000, -0.4000, 1.4000, 1.6000, 0.0000, -0.6000, -0.5000, -0.8000, 1.1000, -0.1000, -0.2000, -1.7000, 0.3000},
    {-0.1000, 0.0000, -0.1000, 1.1000, -0.3000, 0.0000, 1.5000, 1.7000, 1.5000, 0.9000, -0.5000, 0.7000, 0.0000, -0.2000, -0.8000},
    {-0.1000, 0.1000, 0.0000, 5.0000, -1.2000, -0.6000, 1.7000, 16.8000, 8.2000, 7.9000, -2.3000, -3.6000, 0.1000, 0.5000, -7.8000},
    {-0.3000, -0.2000, -0.8000, 2.9000, -1.0000, -0.5000, 1.5000, 8.2000, 12.9000, 11.6000, -2.1000, -2.5000, 0.7000, -1.2000, -7.2000},
    {-0.5000, -0.4000, -1.2000, 3.2000, -1.3000, -0.8000, 0.9000, 7.9000, 11.6000, 20.0000, -2.7000, -3.4000, 0.9000, -1.1000, -8.8000},
    {-0.3000, -0.4000, -1.7000, -1.1000, 0.7000, 1.1000, -0.5000, -2.3000, -2.1000, -2.7000, 14.0000, 0.1000, 0.4000, -3.8000, 16.8000},
    {-0.2000, 0.0000, 0.0000, 0.0000, -0.2000, -0.1000, 0.7000, -3.6000, -2.5000, -3.4000, 0.1000, 5.4000, -0.1000, -0.4000, 2.8000},
    {0.4000, 0.4000, -2.6000, 0.1000, -0.2000, -0.2000, 0.0000, 0.1000, 0.7000, 0.9000, 0.4000, -0.1000, 10.3000, -10.1000, 2.8000},
    {0.3000, 1.0000, 11.1000, 0.1000, -2.4000, -1.7000, -0.2000, 0.5000, -1.2000, -1.1000, -3.8000, -0.4000, -10.1000, 57.8000, -9.4000},
    {-0.1000, -0.2000, -2.8000, -2.6000, -0.3000, 0.3000, -0.8000, -7.8000, -7.2000, -8.8000, 16.8000, 2.8000, 2.8000, -9.4000, 128.3000},
};

static constexpr double kELD15B2[15] = {
    -1.000000e-06, -2.000000e-06, 2.800000e-05, -1.000000e-06, 1.000000e-06, -3.000000e-06, -2.000000e-06, -2.000000e-06, 6.000000e-06, 3.900000e-05, -1.700000e-05, 0.000000e+00, -3.200000e-05, 6.700000e-05, -6.400000e-05
};

static constexpr double kELD140Data2[140][3] = {
    {98.400000, 30.000000, 120.000000},
    {134.000000, 30.000000, 120.000000},
    {141.500000, 60.000000, 60.000000},
    {183.300000, 60.000000, 60.000000},
    {125.000000, 150.000000, 150.000000},
    {91.300000, 150.000000, 150.000000},
    {401.100000, 180.000000, 300.000000},
    {329.500000, 180.000000, 300.000000},
    {386.100000, 300.000000, 510.000000},
    {427.300000, 300.000000, 510.000000},
    {412.200000, 300.000000, 510.000000},
    {370.100000, 300.000000, 510.000000},
    {301.800000, 600.000000, 600.000000},
    {368.000000, 600.000000, 600.000000},
    {301.900000, 600.000000, 600.000000},
    {476.400000, 600.000000, 600.000000},
    {283.100000, 600.000000, 600.000000},
    {414.100000, 600.000000, 600.000000},
    {328.000000, 600.000000, 600.000000},
    {389.400000, 600.000000, 600.000000},
    {354.700000, 600.000000, 600.000000},
    {262.000000, 600.000000, 600.000000},
    {461.500000, 600.000000, 600.000000},
    {371.600000, 600.000000, 600.000000},
    {462.600000, 300.000000, 300.000000},
    {379.200000, 300.000000, 300.000000},
    {530.800000, 360.000000, 360.000000},
    {391.900000, 360.000000, 360.000000},
    {480.100000, 180.000000, 180.000000},
    {319.000000, 180.000000, 180.000000},
    {329.500000, 600.000000, 600.000000},
    {333.800000, 600.000000, 600.000000},
    {390.000000, 600.000000, 600.000000},
    {432.000000, 600.000000, 600.000000},
    {402.000000, 660.000000, 660.000000},
    {428.000000, 900.000000, 900.000000},
    {178.400000, 180.000000, 180.000000},
    {194.100000, 180.000000, 180.000000},
    {474.000000, 600.000000, 600.000000},
    {609.800000, 600.000000, 600.000000},
    {17.800000, 210.000000, 210.000000},
    {6.900000, 366.000000, 366.000000},
    {224.300000, 702.000000, 702.000000},
    {210.000000, 702.000000, 702.000000},
    {212.000000, 702.000000, 702.000000},
    {200.800000, 702.000000, 702.000000},
    {220.000000, 702.000000, 702.000000},
    {232.900000, 702.000000, 702.000000},
    {168.000000, 702.000000, 702.000000},
    {208.400000, 702.000000, 702.000000},
    {443.900000, 1350.000000, 1350.000000},
    {426.000000, 1350.000000, 1350.000000},
    {434.100000, 1350.000000, 1350.000000},
    {402.500000, 1350.000000, 1350.000000},
    {357.400000, 1350.000000, 1350.000000},
    {423.000000, 720.000000, 720.000000},
    {220.000000, 720.000000, 720.000000},
    {369.400000, 2700.000000, 2700.000000},
    {273.500000, 1500.000000, 1500.000000},
    {336.000000, 1656.000000, 1656.000000},
    {432.000000, 2160.000000, 2160.000000},
    {220.000000, 900.000000, 900.000000},
    {410.600000, 1200.000000, 1200.000000},
    {422.700000, 1200.000000, 1200.000000},
    {351.000000, 1014.000000, 1014.000000},
    {296.000000, 1014.000000, 1014.000000},
    {411.100000, 1014.000000, 1014.000000},
    {263.200000, 1014.000000, 1014.000000},
    {370.300000, 1350.000000, 1350.000000},
    {418.700000, 1350.000000, 1350.000000},
    {409.600000, 1350.000000, 1350.000000},
    {412.000000, 1350.000000, 1350.000000},
    {423.200000, 780.000000, 780.000000},
    {428.000000, 1650.000000, 1650.000000},
    {436.000000, 1650.000000, 1650.000000},
    {428.000000, 1650.000000, 1650.000000},
    {425.000000, 1650.000000, 1650.000000},
    {497.200000, 1620.000000, 1620.000000},
    {510.000000, 1482.000000, 1482.000000},
    {470.000000, 1482.000000, 1482.000000},
    {464.100000, 1668.000000, 1668.000000},
    {118.100000, 120.000000, 120.000000},
    {141.300000, 180.000000, 180.000000},
    {132.000000, 120.000000, 180.000000},
    {135.000000, 120.000000, 180.000000},
    {252.000000, 120.000000, 180.000000},
    {221.000000, 120.000000, 180.000000},
    {245.900000, 318.000000, 318.000000},
    {247.900000, 318.000000, 318.000000},
    {183.600000, 318.000000, 318.000000},
    {288.000000, 318.000000, 318.000000},
    {557.400000, 18.000000, 18.000000},
    {529.500000, 18.000000, 18.000000},
    {800.800000, 36.000000, 36.000000},
    {801.500000, 36.000000, 36.000000},
    {582.700000, 138.000000, 204.000000},
    {680.700000, 144.000000, 216.000000},
    {670.700000, 144.000000, 216.000000},
    {651.700000, 144.000000, 216.000000},
    {921.000000, 48.000000, 48.000000},
    {916.800000, 48.000000, 48.000000},
    {911.900000, 36.000000, 54.000000},
    {898.000000, 36.000000, 54.000000},
    {905.000000, 30.000000, 30.000000},
    {846.500000, 30.000000, 30.000000},
    {850.900000, 30.000000, 30.000000},
    {843.700000, 30.000000, 30.000000},
    {841.400000, 36.000000, 36.000000},
    {835.700000, 36.000000, 36.000000},
    {828.800000, 36.000000, 36.000000},
    {846.000000, 36.000000, 36.000000},
    {179.000000, 120.000000, 120.000000},
    {120.800000, 120.000000, 120.000000},
    {121.000000, 120.000000, 120.000000},
    {317.400000, 480.000000, 480.000000},
    {318.400000, 480.000000, 480.000000},
    {335.800000, 480.000000, 480.000000},
    {151.000000, 240.000000, 240.000000},
    {129.500000, 240.000000, 240.000000},
    {130.000000, 120.000000, 120.000000},
    {218.900000, 180.000000, 180.000000},
    {5.400000, 90.000000, 90.000000},
    {45.000000, 90.000000, 90.000000},
    {20.000000, 300.000000, 300.000000},
    {16.300000, 162.000000, 162.000000},
    {20.000000, 114.000000, 114.000000},
    {22.100000, 120.000000, 120.000000},
    {125.000000, 1080.000000, 1080.000000},
    {10.000000, 60.000000, 60.000000},
    {13.000000, 66.000000, 66.000000},
    {7.500000, 12.000000, 6.000000},
    {53.200000, 300.000000, 300.000000},
    {6.400000, 6.000000, 6.000000},
    {69.100000, 60.000000, 60.000000},
    {49.900000, 60.000000, 60.000000},
    {91.000000, 528.000000, 528.000000},
    {41.000000, 300.000000, 300.000000},
    {13.700000, 18.000000, 30.000000},
    {7.400000, 18.000000, 30.000000},
    {28.600000, 72.000000, 120.000000},
};

static constexpr double kELD140Poz[4][7] = {
    {8, 250, 280, 305, 335, 420, 450},
    {32, 220, 250, 320, 350, 390, 420},
    {74, 230, 255, 365, 395, 430, 455},
    {136, 50, 75, 85, 95, 0, 0},
};

struct ProhibitedZone {
    double lower;
    double upper;
};

struct UnitData {
    double pmin;
    double pmax;
    double a;
    double b;
    double c;
    double e;
    double f;
    double upRamp;
    double downRamp;
    double initial;
    std::vector<ProhibitedZone> zones;
};

struct LossCoefficients {
    std::vector<double> B1; // row-major
    std::vector<double> B2;
    double B3;
};

struct DEDProblem {
    int units;
    int hours;
    std::vector<double> demand;
    std::vector<UnitData> unitData;
    LossCoefficients loss;
    double penaltyBalance;
    double penaltyCapacity;
    double penaltyRamp;
    double penaltyPoz;
    bool roundLoss;
};

struct ELDProblem {
    int units;
    double demand;
    std::vector<UnitData> unitData;
    LossCoefficients loss;
    double penaltyBalance;
    double penaltyCapacity;
    double penaltyRamp;
    double penaltyPoz;
    bool roundLoss;
};

struct HydroUnitSpec {
    double qmin;
    double qmax;
    double phMin;
    double phMax;
    double vmin;
    double vmax;
    double vInitial;
    double vFinal;
    int delay;
    int upstreamCount;
    std::array<double, 6> coeffs;
    std::vector<double> inflow;
    std::vector<ProhibitedZone> poz;
};

struct HydroThermalWeights {
    double balance;
    double hydroCapacity;
    double thermalCapacity;
    double discharge;
    double storage;
    double poz;
    double reservoir;
};

struct HydroThermalProblem {
    int units;
    int hours;
    double ptMin;
    double ptMax;
    std::vector<double> demand;
    std::vector<HydroUnitSpec> unitData;
    HydroThermalWeights weights;
    bool valvePoint;
};

enum class MGADSMObjectiveType { OrbitInsertion, TotalDVRendezvous };

struct MGADSMProblem {
    std::vector<int> sequence;
    MGADSMObjectiveType objective;
    double rpTarget;
    double eTarget;
};

constexpr int kHydroUnits = 4;
constexpr int kHydroHours = 24;
constexpr std::array<double, kHydroHours> kHydroDemand = {1370, 1390, 1360, 1290, 1290, 1410, 1650, 2000, 2240, 2320, 2230, 2310,
                                                          2230, 2200, 2130, 2070, 2130, 2140, 2240, 2280, 2240, 2120, 1850, 1590};
constexpr std::array<std::array<double, 6>, kHydroUnits> kHydroCoefficients = {{{-0.0042, -0.42, 0.030, 0.90, 10.0, -50.0},
                                                                               {-0.0040, -0.30, 0.015, 1.14, 9.5, -70.0},
                                                                               {-0.0016, -0.30, 0.014, 0.55, 5.5, -40.0},
                                                                               {-0.0030, -0.31, 0.027, 1.44, 14.0, -90.0}}};
constexpr std::array<std::array<double, kHydroHours>, kHydroUnits> kHydroInflows = {
    {{10, 9, 8, 7, 6, 7, 8, 9, 10, 11, 12, 10, 11, 12, 11, 10, 9, 8, 7, 6, 7, 8, 9, 10},
     {8, 8, 9, 9, 8, 7, 6, 7, 8, 9, 9, 8, 8, 9, 9, 8, 7, 6, 7, 8, 9, 9, 8, 8},
     {8.1, 8.2, 4, 2, 3, 4, 3, 2, 1, 1, 1, 2, 4, 3, 3, 2, 2, 2, 1, 1, 2, 2, 1, 0},
     {2.8, 2.4, 1.6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}};
constexpr std::array<double, kHydroUnits> kHydroPhMin = {0.0, 0.0, 0.0, 0.0};
constexpr std::array<double, kHydroUnits> kHydroPhMax = {500.0, 500.0, 500.0, 500.0};
constexpr std::array<double, kHydroUnits> kHydroQmin = {5.0, 6.0, 10.0, 13.0};
constexpr std::array<double, kHydroUnits> kHydroQmax = {15.0, 15.0, 30.0, 25.0};
constexpr std::array<double, kHydroUnits> kHydroVmin = {80.0, 60.0, 100.0, 70.0};
constexpr std::array<double, kHydroUnits> kHydroVmax = {150.0, 120.0, 240.0, 160.0};
constexpr std::array<double, kHydroUnits> kHydroVInitial = {100.0, 80.0, 170.0, 120.0};
constexpr std::array<double, kHydroUnits> kHydroVFinal = {120.0, 70.0, 170.0, 140.0};
constexpr std::array<int, kHydroUnits> kHydroDelay = {2, 3, 4, 0};
constexpr std::array<int, kHydroUnits> kHydroUpstream = {0, 0, 2, 1};
constexpr std::array<std::array<double, 2>, kHydroUnits> kHydroPozBounds = {{{8.0, 9.0}, {7.0, 8.0}, {22.0, 27.0}, {16.0, 18.0}}};
constexpr HydroThermalWeights kHydroBaseWeights{1e4, 2e4, 0.0, 1e4, 1e5, 0.0, 1e6};

double computeLoss(const double *row, int units, const LossCoefficients &loss) {
    double result = 0.0;
    for (int i = 0; i < units; ++i) {
        for (int j = 0; j < units; ++j) {
            result += row[i] * loss.B1[i * units + j] * row[j];
        }
    }
    for (int i = 0; i < units && i < static_cast<int>(loss.B2.size()); ++i) {
        result += loss.B2[i] * row[i];
    }
    result += loss.B3;
    return result;
}

double rampPenaltyTerm(double value, double limit) {
    const double diff = value - limit;
    return std::abs(diff) - diff;
}

double boundaryPenalty(double value, double bound) {
    const double diff = value - bound;
    return std::abs(diff) - diff;
}

double computePozPenalty(double xi, const std::vector<ProhibitedZone> &zones) {
    double penalty = 0.0;
    for (const auto &zone : zones) {
        if (zone.upper > zone.lower && xi > zone.lower && xi < zone.upper) {
            penalty += std::min(xi - zone.lower, zone.upper - xi);
        }
    }
    return penalty;
}

double evaluateDED(const double *x, int nx, const DEDProblem &problem) {
    const int units = problem.units;
    const int hours = problem.hours;
    if (nx != units * hours) {
        throw std::runtime_error("Invalid dimension for DED problem.");
    }
    double totalPenalty = 0.0;
    double totalCost = 0.0;
    std::vector<double> previous(units, std::numeric_limits<double>::quiet_NaN());
    for (int h = 0; h < hours; ++h) {
        const double *row = x + h * units;
        double loss = computeLoss(row, units, problem.loss);
        if (problem.roundLoss) {
            loss = std::round(loss * 10000.0) / 10000.0;
        }
        double sumRow = 0.0;
        double capacityPenalty = 0.0;
        double pozPenalty = 0.0;
        for (int u = 0; u < units; ++u) {
            const double xi = row[u];
            const auto &unit = problem.unitData[u];
            sumRow += xi;
            capacityPenalty += boundaryPenalty(xi, unit.pmin);
            capacityPenalty += boundaryPenalty(unit.pmax, xi);
            pozPenalty += computePozPenalty(xi, unit.zones);
        }
        const double balancePenalty = std::abs(problem.demand[h] + loss - sumRow);
        double rampPenalty = 0.0;
        if (h > 0) {
            for (int u = 0; u < units; ++u) {
                const auto &unit = problem.unitData[u];
                const double prev = previous[u];
                const double downLimit = std::max(unit.pmin, prev - unit.downRamp);
                const double upLimit = std::min(unit.pmax, prev + unit.upRamp);
                rampPenalty += rampPenaltyTerm(row[u], downLimit);
                rampPenalty += rampPenaltyTerm(upLimit, row[u]);
            }
        }
        double hourPenalty = problem.penaltyBalance * balancePenalty +
                             problem.penaltyCapacity * capacityPenalty +
                             problem.penaltyRamp * rampPenalty +
                             problem.penaltyPoz * pozPenalty;
        totalPenalty += hourPenalty;

        double hourCost = 0.0;
        for (int u = 0; u < units; ++u) {
            const auto &unit = problem.unitData[u];
            const double xi = row[u];
            hourCost += unit.a * xi * xi + unit.b * xi + unit.c;
            if (unit.e != 0.0 && unit.f != 0.0) {
                hourCost += std::abs(unit.e * std::sin(unit.f * (unit.pmin - xi)));
            }
        }
        totalCost += hourCost;
        for (int u = 0; u < units; ++u) {
            previous[u] = row[u];
        }
    }
    return totalCost + totalPenalty;
}

double evaluateELD(const double *x, int nx, const ELDProblem &problem) {
    if (nx != problem.units) {
        throw std::runtime_error("Invalid dimension for ELD problem.");
    }
    const int units = problem.units;
    double loss = computeLoss(x, units, problem.loss);
    if (problem.roundLoss) {
        loss = std::round(loss * 10000.0) / 10000.0;
    }
    double capacityPenalty = 0.0;
    double pozPenalty = 0.0;
    double rampPenalty = 0.0;
    double sumx = 0.0;
    double cost = 0.0;
    for (int u = 0; u < units; ++u) {
        const auto &unit = problem.unitData[u];
        const double xi = x[u];
        sumx += xi;
        capacityPenalty += boundaryPenalty(xi, unit.pmin);
        capacityPenalty += boundaryPenalty(unit.pmax, xi);
        cost += unit.a * xi * xi + unit.b * xi + unit.c;
        if (unit.e != 0.0 && unit.f != 0.0) {
            cost += std::abs(unit.e * std::sin(unit.f * (unit.pmin - xi)));
        }
        if (!unit.zones.empty()) {
            pozPenalty += computePozPenalty(xi, unit.zones);
        }
        if (!std::isnan(unit.initial) && (unit.upRamp > 0.0 || unit.downRamp > 0.0)) {
            const double downLimit = std::max(unit.pmin, unit.initial - unit.downRamp);
            const double upLimit = std::min(unit.pmax, unit.initial + unit.upRamp);
            rampPenalty += rampPenaltyTerm(xi, downLimit);
            rampPenalty += rampPenaltyTerm(upLimit, xi);
        }
    }
    const double balancePenalty = std::abs(problem.demand + loss - sumx);
    const double totalPenalty = problem.penaltyBalance * balancePenalty +
                                problem.penaltyCapacity * capacityPenalty +
                                problem.penaltyRamp * rampPenalty +
                                problem.penaltyPoz * pozPenalty;
    return cost + totalPenalty;
}

double evaluateHydroThermal(const double *x, int nx, const HydroThermalProblem &problem) {
    const int units = problem.units;
    const int hours = problem.hours;
    if (nx != units * hours) {
        throw std::runtime_error("Invalid dimension for hydro-thermal problem.");
    }
    if (static_cast<int>(problem.unitData.size()) != units) {
        throw std::runtime_error("Hydro problem configuration mismatch.");
    }
    const int maxDelay = [&problem]() {
        int value = 0;
        for (const auto &unit : problem.unitData) {
            value = std::max(value, unit.delay);
        }
        return value;
    }();
    const int totalCols = hours + maxDelay;
    std::vector<double> discharge(units * hours, 0.0);
    for (int hour = 0; hour < hours; ++hour) {
        for (int unit = 0; unit < units; ++unit) {
            discharge[unit * hours + hour] = x[hour * units + unit];
        }
    }
    std::vector<double> allDischarges(units * totalCols, 0.0);
    for (int unit = 0; unit < units; ++unit) {
        for (int hour = 0; hour < hours; ++hour) {
            allDischarges[unit * totalCols + (maxDelay + hour)] = discharge[unit * hours + hour];
        }
    }
    const int storageCols = hours + 1;
    std::vector<double> storage(units * storageCols, 0.0);
    for (int unit = 0; unit < units; ++unit) {
        storage[unit * storageCols] = problem.unitData[unit].vInitial;
    }
    for (int i = 0; i < units; ++i) {
        for (int hour = 0; hour < hours; ++hour) {
            double upstreamVolume = 0.0;
            const int upstreamCount = problem.unitData[i].upstreamCount;
            const int start = std::max(0, i - upstreamCount);
            for (int upstream = start; upstream < i; ++upstream) {
                const int delay = problem.unitData[upstream].delay;
                const int column = hour + maxDelay - delay;
                if (column >= 0 && column < totalCols) {
                    upstreamVolume += allDischarges[upstream * totalCols + column];
                }
            }
            const double previous = storage[i * storageCols + hour];
            const double q = discharge[i * hours + hour];
            const double inflow = problem.unitData[i].inflow[hour];
            storage[i * storageCols + (hour + 1)] = previous + upstreamVolume - q + inflow;
        }
    }

    double sumBalance = 0.0;
    double sumHydroCapacity = 0.0;
    double sumThermalCapacity = 0.0;
    double sumDischarge = 0.0;
    double sumStorage = 0.0;
    double sumPoz = 0.0;
    double totalCost = 0.0;

    for (int hour = 0; hour < hours; ++hour) {
        double hydroGeneration = 0.0;
        double dischargePenalty = 0.0;
        double storagePenalty = 0.0;
        double hydroCapacityPenalty = 0.0;
        double pozPenalty = 0.0;

        for (int unit = 0; unit < units; ++unit) {
            const auto &spec = problem.unitData[unit];
            const double q = discharge[unit * hours + hour];
            const double volume = storage[unit * storageCols + (hour + 1)];
            dischargePenalty += boundaryPenalty(q, spec.qmin);
            dischargePenalty += boundaryPenalty(spec.qmax, q);
            storagePenalty += boundaryPenalty(volume, spec.vmin);
            storagePenalty += boundaryPenalty(spec.vmax, volume);

            double ph = spec.coeffs[0] * volume * volume + spec.coeffs[1] * q * q +
                        spec.coeffs[2] * volume * q + spec.coeffs[3] * volume + spec.coeffs[4] * q + spec.coeffs[5];
            if (ph < 0.0) {
                ph = 0.0;
            }
            hydroGeneration += ph;
            hydroCapacityPenalty += boundaryPenalty(ph, spec.phMin);
            hydroCapacityPenalty += boundaryPenalty(spec.phMax, ph);
            if (!spec.poz.empty()) {
                pozPenalty += computePozPenalty(q, spec.poz);
            }
        }

        const double pThermal = problem.demand[hour] - hydroGeneration;
        const double thermalCapacityPenalty =
            boundaryPenalty(pThermal, problem.ptMin) + boundaryPenalty(problem.ptMax, pThermal);
        const double balancePenalty = std::abs(problem.demand[hour] - hydroGeneration - pThermal);
        double hourCost = 5000.0 + 19.2 * pThermal + 0.002 * pThermal * pThermal;
        if (problem.valvePoint) {
            hourCost += std::abs(700.0 * std::sin(0.085 * (problem.ptMin - pThermal)));
        }

        sumDischarge += dischargePenalty;
        sumStorage += storagePenalty;
        sumHydroCapacity += hydroCapacityPenalty;
        sumPoz += pozPenalty;
        sumThermalCapacity += thermalCapacityPenalty;
        sumBalance += balancePenalty;
        totalCost += hourCost;
    }

    double reservoirPenalty = 0.0;
    for (int unit = 0; unit < units; ++unit) {
        const auto &spec = problem.unitData[unit];
        const double initialDiff = std::abs(storage[unit * storageCols] - spec.vInitial);
        const double finalDiff = std::abs(storage[unit * storageCols + hours] - spec.vFinal);
        reservoirPenalty += initialDiff + finalDiff;
    }

    const auto &weights = problem.weights;
    const double totalPenalty = weights.balance * sumBalance + weights.hydroCapacity * sumHydroCapacity +
                                weights.thermalCapacity * sumThermalCapacity + weights.discharge * sumDischarge +
                                weights.storage * sumStorage + weights.poz * sumPoz +
                                weights.reservoir * reservoirPenalty;
    return totalCost + totalPenalty;
}

namespace mgadsm {

constexpr double kMuSun = 1.32712428e11;
constexpr double kSecondsPerDay = 86400.0;

inline double clampCos(double value) {
    return std::max(-1.0, std::min(1.0, value));
}

inline Eigen::Vector3d unitVector(const Eigen::Vector3d &v) {
    const double n = v.norm();
    if (n == 0.0) {
        return Eigen::Vector3d::Zero();
    }
    return v / n;
}

double m2E(double M, double e);
double e2M(double E, double e);
std::array<double, 6> ic2par(const Eigen::Vector3d &r0, const Eigen::Vector3d &v0, double mu);
double ni2E(double ni, double e);
std::pair<Eigen::Vector3d, Eigen::Vector3d> par2IC(const std::array<double, 6> &elements, double mu);
void plephAn(double mjd2000, int planet, Eigen::Vector3d &r, Eigen::Vector3d &v);

Eigen::Vector3d propagatePosition(const Eigen::Vector3d &r0,
                                  const Eigen::Vector3d &v0,
                                  double dt,
                                  double mu,
                                  Eigen::Vector3d &vOut) {
    Eigen::Matrix3d DD = Eigen::Matrix3d::Identity();
    Eigen::Vector3d rAdj = r0;
    Eigen::Vector3d vAdj = v0;
    const Eigen::Vector3d h = r0.cross(v0);
    Eigen::Vector3d ih = unitVector(h);
    if (std::abs(std::abs(ih.z()) - 1.0) < 1e-3) {
        DD << 1.0, 0.0, 0.0,
              0.0, 0.0, 1.0,
              0.0, -1.0, 0.0;
        rAdj = DD * rAdj;
        vAdj = DD * vAdj;
    }
    auto elements = ic2par(rAdj, vAdj, mu);
    const double ecc = elements[1];
    const double a = elements[0];
    const double rate = (ecc < 1.0) ? std::sqrt(mu / (a * a * a)) : std::sqrt(-mu / (a * a * a));
    const double M0 = e2M(elements[5], ecc);
    const double M = M0 + rate * dt;
    elements[5] = m2E(M, ecc);
    auto state = par2IC(elements, mu);
    Eigen::Vector3d rVec = DD.transpose() * state.first;
    vOut = DD.transpose() * state.second;
    return rVec;
}

struct LambertResult {
    Eigen::Vector3d v1;
    Eigen::Vector3d v2;
    double semiMajor;
    double p;
};

double x2tof(double x, double s, double c, bool longWay, int revolutions);
double tofExpression(double sigma, double alpha, double beta, int revolutions);

LambertResult lambert(const Eigen::Vector3d &r1,
                      const Eigen::Vector3d &r2,
                      double tofSeconds,
                      double mu,
                      bool longWay) {
    if (tofSeconds <= 0.0) {
        throw std::runtime_error("Lambert transfer time must be positive.");
    }
    const double R = r1.norm();
    const double V = std::sqrt(mu / R);
    const double T = R / V;
    const Eigen::Vector3d r1n = r1 / R;
    const Eigen::Vector3d r2n = r2 / R;
    const double t = tofSeconds / T;
    const double r2mod = r2n.norm();
    double theta = std::acos(clampCos(r1n.dot(r2n / r2mod)));
    if (longWay) {
        theta = 2.0 * PI - theta;
    }
    const double c = std::sqrt(1.0 + r2mod * r2mod - 2.0 * r2mod * std::cos(theta));
    const double s = (1.0 + r2mod + c) / 2.0;
    const double am = s / 2.0;
    const double lambda = std::sqrt(r2mod) * std::cos(theta / 2.0) / s;

    double x;
    {
        double x1 = std::log(1.0 - 0.5233);
        double x2 = std::log(1.0 + 0.5233);
        double y1 = std::log(x2tof(std::exp(x1) - 1.0, s, c, longWay, 0)) - std::log(t);
        double y2 = std::log(x2tof(std::exp(x2) - 1.0, s, c, longWay, 0)) - std::log(t);
        double err = 1.0;
        while (err > 1e-11 && y1 != y2) {
            const double xNew = (x1 * y2 - y1 * x2) / (y2 - y1);
            const double yNew = std::log(x2tof(std::exp(xNew) - 1.0, s, c, longWay, 0)) - std::log(t);
            err = std::abs(x1 - xNew);
            x1 = x2;
            y1 = y2;
            x2 = xNew;
            y2 = yNew;
        }
        x = std::exp(x2) - 1.0;
    }

    const double a = am / (1.0 - x * x);
    double beta;
    double psi;
    double eta2;
    if (x < 1.0) {
        beta = 2.0 * std::asin(std::sqrt((s - c) / (2.0 * a)));
        if (longWay) {
            beta = -beta;
        }
        const double alpha = 2.0 * std::acos(x);
        psi = (alpha - beta) / 2.0;
        eta2 = 2.0 * a * std::sin(psi) * std::sin(psi) / s;
    } else {
        beta = 2.0 * std::asinh(std::sqrt((c - s) / (2.0 * a)));
        if (longWay) {
            beta = -beta;
        }
        const double alpha = 2.0 * std::acosh(x);
        psi = (alpha - beta) / 2.0;
        eta2 = -2.0 * a * std::sinh(psi) * std::sinh(psi) / s;
    }
    const double eta = std::sqrt(std::abs(eta2));
    const double p = r2mod / (am * eta2) * std::sin(theta / 2.0) * std::sin(theta / 2.0);
    const double sigma1 = (1.0 / eta) / std::sqrt(am) * (2.0 * lambda * am - (lambda + x * eta));
    Eigen::Vector3d ih = unitVector(r1n.cross(r2n));
    if (longWay) {
        ih = -ih;
    }
    const double vr1 = sigma1;
    const double vt1 = std::sqrt(std::abs(p));
    const Eigen::Vector3d v1 = (vr1 * r1n + vt1 * ih.cross(r1n)) * V;
    const double vt2 = vt1 / r2mod;
    const double vr2 = -vr1 + (vt1 - vt2) / std::tan(theta / 2.0);
    const Eigen::Vector3d v2 = ((vr2 * r2n / r2mod) + vt2 * ih.cross(r2n / r2mod)) * V;
    return {v1, v2, a * R, p * R};
}

double evaluate(const double *x, int nx, const MGADSMProblem &problem) {
    const int N = static_cast<int>(problem.sequence.size());
    if (N < 2) {
        throw std::runtime_error("MGADSM problem must contain at least two bodies.");
    }
    const int expected = 4 + 2 * (N - 1) + 2 * (N - 2);
    if (nx != expected) {
        throw std::runtime_error("Invalid MGADSM dimension.");
    }
    const double tdep = x[0];
    const double vinfMag = x[1];
    const double udir = x[2];
    const double vdir = x[3];
    std::vector<double> tof(N - 1);
    std::vector<double> alpha(N - 1);
    for (int i = 0; i < N - 1; ++i) {
        tof[i] = x[4 + i];
        alpha[i] = x[4 + (N - 1) + i];
    }
    std::vector<double> rpNonDim(N - 2);
    std::vector<double> gamma(N - 2);
    const int rpOffset = 4 + 2 * (N - 1);
    const int gammaOffset = rpOffset + (N - 2);
    for (int i = 0; i < N - 2; ++i) {
        rpNonDim[i] = x[rpOffset + i];
        gamma[i] = x[gammaOffset + i];
    }
    constexpr std::array<double, 6> kPlanetMu = {22321.0, 324860.0, 398601.19, 42828.3, 1.267e8, 37.93951970883e6};
    constexpr std::array<double, 6> kPlanetRadius = {2440.0, 6052.0, 6378.0, 3397.0, 71492.0, 60330.0};
    std::vector<Eigen::Vector3d> r(N), v(N);
    std::vector<Eigen::Vector3d> v_sc_pl_in(N), v_sc_pl_out(N);
    std::vector<Eigen::Vector3d> rd(N - 1);
    std::vector<Eigen::Vector3d> v_sc_dsm_in(N - 1), v_sc_dsm_out(N - 1);
    std::vector<double> muVec(N);
    double currentTime = tdep;
    for (int i = 0; i < N; ++i) {
        const int body = std::abs(problem.sequence[i]);
        plephAn(currentTime, body, r[i], v[i]);
        if (body < 1 || body > 6) {
            throw std::runtime_error("MGADSM currently supports bodies up to Saturn.");
        }
        muVec[i] = kPlanetMu[body - 1];
        if (i < N - 1) {
            currentTime += tof[i];
        }
    }
    std::vector<double> rp(N - 2, 0.0);
    for (int i = 0; i < N - 2; ++i) {
        const int body = std::abs(problem.sequence[i + 1]);
        if (body < 1 || body > 6) {
            throw std::runtime_error("Unsupported fly-by body.");
        }
        rp[i] = rpNonDim[i] * kPlanetRadius[body - 1];
    }
    Eigen::Vector3d vtemp = r[0].cross(v[0]);
    const Eigen::Vector3d iP1 = unitVector(v[0]);
    const Eigen::Vector3d zP1 = unitVector(vtemp);
    Eigen::Vector3d jP1 = zP1.cross(iP1);
    if (jP1.norm() == 0.0) {
        jP1 = Eigen::Vector3d::UnitY();
    } else {
        jP1.normalize();
    }
    const double theta = 2.0 * PI * udir;
    const double phi = std::acos(clampCos(2.0 * vdir - 1.0)) - PI / 2.0;
    const Eigen::Vector3d vinf = vinfMag *
                                 (std::cos(theta) * std::cos(phi) * iP1 +
                                  std::sin(theta) * std::cos(phi) * jP1 + std::sin(phi) * zP1);
    v_sc_pl_in[0] = v[0];
    v_sc_pl_out[0] = v[0] + vinf;
    std::vector<double> tDSM(N - 1, 0.0);
    tDSM[0] = alpha[0] * tof[0];
    rd[0] = propagatePosition(r[0], v_sc_pl_out[0], tDSM[0] * kSecondsPerDay, kMuSun, v_sc_dsm_in[0]);
    const bool longWayFirst = rd[0].cross(r[1]).z() <= 0.0;
    auto lamFirst = lambert(rd[0], r[1], (tof[0] * (1.0 - alpha[0])) * kSecondsPerDay, kMuSun, longWayFirst);
    v_sc_dsm_out[0] = lamFirst.v1;
    v_sc_pl_in[1] = lamFirst.v2;
    std::vector<double> DV(N, 0.0);
    DV[0] = (v_sc_dsm_out[0] - v_sc_dsm_in[0]).norm();
    for (int i = 0; i < N - 2; ++i) {
        Eigen::Vector3d v_rel_in = v_sc_pl_in[i + 1] - v[i + 1];
        const double e = 1.0 + rp[i] / muVec[i + 1] * v_rel_in.squaredNorm();
        const double beta = 2.0 * std::asin(1.0 / e);
        Eigen::Vector3d ix = unitVector(v_rel_in);
        Eigen::Vector3d iy = ix.cross(unitVector(v[i + 1]));
        if (iy.norm() == 0.0) {
            iy = ix.cross(Eigen::Vector3d::UnitX());
        }
        iy.normalize();
        const Eigen::Vector3d iz = ix.cross(iy);
        const double gammaVal = gamma[i];
        const Eigen::Vector3d iVout = std::cos(beta) * ix + std::cos(gammaVal) * std::sin(beta) * iy +
                                      std::sin(gammaVal) * std::sin(beta) * iz;
        const Eigen::Vector3d v_rel_out = v_rel_in.norm() * iVout;
        v_sc_pl_out[i + 1] = v[i + 1] + v_rel_out;
        tDSM[i + 1] = alpha[i + 1] * tof[i + 1];
        rd[i + 1] =
            propagatePosition(r[i + 1], v_sc_pl_out[i + 1], tDSM[i + 1] * kSecondsPerDay, kMuSun, v_sc_dsm_in[i + 1]);
        const bool lw = rd[i + 1].cross(r[i + 2]).z() <= 0.0;
        auto lam = lambert(rd[i + 1], r[i + 2], (tof[i + 1] * (1.0 - alpha[i + 1])) * kSecondsPerDay, kMuSun, lw);
        v_sc_dsm_out[i + 1] = lam.v1;
        v_sc_pl_in[i + 2] = lam.v2;
        DV[i + 1] = (v_sc_dsm_out[i + 1] - v_sc_dsm_in[i + 1]).norm();
    }
    const Eigen::Vector3d v_rel_final = v.back() - v_sc_pl_in.back();
    double arrivalDV = 0.0;
    if (problem.objective == MGADSMObjectiveType::OrbitInsertion) {
        const double muTarget = muVec.back();
        const double rpTarget = problem.rpTarget;
        const double eTarget = problem.eTarget;
        const double dvper = std::sqrt(v_rel_final.squaredNorm() + 2.0 * muTarget / rpTarget);
        const double dvper2 = std::sqrt(2.0 * muTarget / rpTarget - muTarget / rpTarget * (1.0 - eTarget));
        arrivalDV = std::abs(dvper - dvper2);
    } else {
        arrivalDV = v_rel_final.norm();
    }
    DV.back() = arrivalDV;
    double DVtot = 0.0;
    for (double val : DV) {
        DVtot += val;
    }
    if (problem.objective == MGADSMObjectiveType::OrbitInsertion) {
        return DVtot;
    }
    return DVtot + vinfMag;
}

double x2tof(double x, double s, double c, bool longWay, int revolutions) {
    const double am = s / 2.0;
    const double a = am / (1.0 - x * x);
    double beta;
    double alpha;
    if (x < 1.0) {
        beta = 2.0 * std::asin(std::sqrt((s - c) / (2.0 * a)));
        if (longWay) {
            beta = -beta;
        }
        alpha = 2.0 * std::acos(x);
    } else {
        alpha = 2.0 * std::acosh(x);
        beta = 2.0 * std::asinh(std::sqrt((s - c) / (-2.0 * a)));
        if (longWay) {
            beta = -beta;
        }
    }
    return tofExpression(a, alpha, beta, revolutions);
}

double tofExpression(double sigma, double alpha, double beta, int revolutions) {
    if (sigma > 0.0) {
        return sigma * std::sqrt(sigma) * ((alpha - std::sin(alpha)) - (beta - std::sin(beta)) + revolutions * 2.0 * PI);
    }
    return -sigma * std::sqrt(-sigma) * ((std::sinh(alpha) - alpha) - (std::sinh(beta) - beta));
}

double m2E(double M, double e) {
    double E = M + e * std::cos(M);
    double err = 1.0;
    int iter = 0;
    while (err > 1e-10 && iter < 100) {
        ++iter;
        double f = (E - e * std::sin(E) - M);
        double fp = 1.0 - e * std::cos(E);
        double delta = f / fp;
        E -= delta;
        err = std::abs(delta);
    }
    return E;
}

double e2M(double E, double e) {
    if (e < 1.0) {
        return E - e * std::sin(E);
    }
    return e * std::tan(E) - std::log(std::tan(E / 2.0 + PI / 4.0));
}

std::array<double, 6> ic2par(const Eigen::Vector3d &r0, const Eigen::Vector3d &v0, double mu) {
    const Eigen::Vector3d k(0.0, 0.0, 1.0);
    const Eigen::Vector3d h = r0.cross(v0);
    const double hNorm = h.norm();
    const double p = h.squaredNorm() / mu;
    Eigen::Vector3d n = k.cross(h);
    double nNorm = n.norm();
    if (nNorm == 0.0) {
        n = Eigen::Vector3d::UnitX();
        nNorm = 1.0;
    }
    n /= nNorm;
    const double rNorm = r0.norm();
    Eigen::Vector3d eVec = (v0.cross(h) / mu) - (r0 / rNorm);
    const double e = eVec.norm();
    std::array<double, 6> elements{};
    elements[0] = p / (1.0 - e);
    elements[1] = e;
    const double i = std::acos(clampCos(h.z() / hNorm));
    elements[2] = i;
    double omega = std::acos(clampCos(n.x()));
    if (n.y() < 0.0) {
        omega = 2.0 * PI - omega;
    }
    elements[3] = omega;
    double argPeri = std::acos(clampCos(n.dot(eVec) / e));
    if (eVec.z() < 0.0) {
        argPeri = 2.0 * PI - argPeri;
    }
    elements[4] = argPeri;
    double trueAnomaly = std::acos(clampCos(eVec.dot(r0) / (e * rNorm)));
    if (r0.dot(v0) < 0.0) {
        trueAnomaly = 2.0 * PI - trueAnomaly;
    }
    elements[5] = ni2E(trueAnomaly, e);
    return elements;
}

double ni2E(double ni, double e) {
    if (e < 1.0) {
        const double factor = std::sqrt((1.0 - e) / (1.0 + e));
        return 2.0 * std::atan(factor * std::tan(ni / 2.0));
    }
    const double factor = std::sqrt((e - 1.0) / (e + 1.0));
    return 2.0 * std::atan(factor * std::tan(ni / 2.0));
}

std::pair<Eigen::Vector3d, Eigen::Vector3d> par2IC(const std::array<double, 6> &elements, double mu) {
    const double a = elements[0];
    const double e = elements[1];
    const double i = elements[2];
    const double Omega = elements[3];
    const double omega = elements[4];
    const double EA = elements[5];
    double xper;
    double yper;
    double xdotper;
    double ydotper;
    if (e < 1.0) {
        const double b = a * std::sqrt(1.0 - e * e);
        const double n = std::sqrt(mu / (a * a * a));
        xper = a * (std::cos(EA) - e);
        yper = b * std::sin(EA);
        xdotper = -(a * n * std::sin(EA)) / (1.0 - e * std::cos(EA));
        ydotper = (b * n * std::cos(EA)) / (1.0 - e * std::cos(EA));
    } else {
        const double b = -a * std::sqrt(e * e - 1.0);
        const double n = std::sqrt(-mu / (a * a * a));
        const double dNdzeta = e * (1.0 + std::tan(EA) * std::tan(EA)) -
                               (0.5 + 0.5 * std::pow(std::tan(EA / 2.0 + PI / 4.0), 2)) /
                                   std::tan(EA / 2.0 + PI / 4.0);
        xper = a / std::cos(EA) - a * e;
        yper = b * std::tan(EA);
        xdotper = a * std::tan(EA) / std::cos(EA) * n / dNdzeta;
        ydotper = b / (std::cos(EA) * std::cos(EA)) * n / dNdzeta;
    }
    Eigen::Matrix3d R;
    const double cO = std::cos(Omega);
    const double sO = std::sin(Omega);
    const double co = std::cos(omega);
    const double so = std::sin(omega);
    const double ci = std::cos(i);
    const double si = std::sin(i);
    R(0, 0) = cO * co - sO * so * ci;
    R(0, 1) = -cO * so - sO * co * ci;
    R(0, 2) = sO * si;
    R(1, 0) = sO * co + cO * so * ci;
    R(1, 1) = -sO * so + cO * co * ci;
    R(1, 2) = -cO * si;
    R(2, 0) = so * si;
    R(2, 1) = co * si;
    R(2, 2) = ci;
    Eigen::Vector3d r = R * Eigen::Vector3d(xper, yper, 0.0);
    Eigen::Vector3d v = R * Eigen::Vector3d(xdotper, ydotper, 0.0);
    return {r, v};
}

void plephAn(double mjd2000, int planet, Eigen::Vector3d &r, Eigen::Vector3d &v) {
    const double RAD = PI / 180.0;
    const double KM = 1.49597870691e8;
    std::array<double, 6> E{};
    double T = (mjd2000 + 36525.0) / 36525.0;
    double TT = T * T;
    double TTT = TT * T;
    switch (planet) {
    case 1:
        E = {0.38709860,
             0.20561421 + 0.00002046 * T - 0.00000003 * TT,
             7.002880555555556 + 0.0018608333333333333 * T - 1.8333333333333333e-05 * TT,
             47.14594444444444 + 1.1852083333333333 * T + 0.0001738888888888889 * TT,
             28.753752777777777 + 0.3702805555555556 * T + 0.00012083333333333333 * TT,
             102.27938055555556 + (149472.5152888889 + 6.388888888888889e-06 * T) * T};
        break;
    case 2:
        E = {0.72333160,
             0.00682069 - 0.00004774 * T + 9.1e-8 * TT,
             3.3936305555555556 + 0.0010058333333333333 * T - 9.722222222222222e-07 * TT,
             75.77964722222222 + 0.89985 * T + 0.00041 * TT,
             54.38418611111111 + 0.5081861111111111 * T - 0.001386388888888889 * TT,
             212.60321944444445 + (58517.803875 + 0.0012860555555555556 * T) * T};
        break;
    case 3:
        E = {1.00000023,
             0.01675104 - 0.0000418 * T - 1.26e-7 * TT,
             0.0,
             0.0,
             101.22083333333333 + 1.719175 * T + 0.0004527777777777778 * TT + 3.3333333333333335e-06 * TTT,
             358.47584444444445 + (35990.4975 - 0.00015027777777777778 * T - 3.3333333333333335e-06 * TT) * T};
        break;
    case 4:
        E = {1.523688399,
             0.0933129 + 0.000092064 * T - 7.7e-8 * TT,
             1.8503333333333333 - 0.000675 * T + 1.2611111111111111e-05 * TT,
             48.78644166666667 + 0.7709916666666667 * T - 1.388888888888889e-06 * TT - 5.333333333333333e-06 * TTT,
             285.4317611111111 + 1.0697666666666667 * T + 0.00013125 * TT + 4.138888888888889e-06 * TTT,
             319.529425 + (19139.8585 + 0.00018080555555555556 * T + 1.1944444444444444e-06 * TT) * T};
        break;
    case 5:
        E = {5.202561,
             0.04833475 + 0.00016418 * T - 4.676e-07 * TT - 1.7e-09 * TTT,
             1.308736111111111 - 0.005696111111111111 * T + 3.888888888888889e-06 * TT,
             99.44338611111111 + 1.01053 * T + 0.00035222222222222225 * TT - 8.511111111111112e-06 * TTT,
             273.2775416666667 + 0.5994316666666667 * T + 0.00070405 * TT + 5.077777777777778e-06 * TTT,
             225.32832777777778 + (3034.692023888889 - 0.0007215888888888889 * T + 1.7844444444444444e-06 * TT) * T};
        break;
    case 6:
        E = {9.554747,
             0.05589232 - 0.0003455 * T - 7.28e-07 * TT + 7.4e-10 * TTT,
             2.4925194444444444 - 0.003918888888888889 * T - 1.548888888888889e-05 * TT + 4.4444444444444447e-08 * TTT,
             112.79038888888889 + 0.8731951388888889 * T - 0.00015218055555555556 * TT - 5.305555555555556e-06 * TTT,
             338.3077722222222 + 1.0852206944444444 * T + 0.0009785416666666667 * TT + 9.916666666666666e-06 * TTT,
             175.46621666666666 + (1221.5514677777778 - 0.0005018194444444444 * T - 5.1944444444444446e-06 * TT) * T};
        break;
    case 7:
        E = {19.21814,
             0.0463444 - 0.00002658 * T + 7.7e-08 * TT,
             0.7724638888888889 + 0.0006252777777777778 * T + 3.95e-05 * TT,
             73.47709722222223 + 0.4986677777777778 * T + 0.0013116666666666667 * TT,
             98.07155277777777 + 0.985765 * T - 0.0010744722222222222 * TT - 6.055555555555555e-07 * TTT,
             72.64881944444444 + (428.3791130555556 + 7.884444444444444e-05 * T + 1.1111111111111112e-09 * TT) * T};
        break;
    case 8:
        E = {30.10957,
             0.00899704 + 0.00000633 * T - 2.0e-12 * TT,
             1.7792416666666667 - 0.00954361111111111 * T - 9.111111111111111e-06 * TT,
             130.68135833333332 + 1.098935 * T + 0.00024986666666666665 * TT - 4.717777777777778e-06 * TTT,
             276.0459666666667 + 0.32563944444444444 * T + 0.00014095 * TT + 4.113333333333333e-06 * TTT,
             37.730669444444445 + (218.46133972222223 - 7.033333333333333e-05 * T) * T};
        break;
    case 9: {
        double Tp = mjd2000 / 36525.0;
        double TTp = Tp * Tp;
        double TTTp = TTp * Tp;
        double TTTTp = TTTp * Tp;
        double TTTTTp = TTTTp * Tp;
        E = {39.34041961252520 + 4.33305138120726 * Tp - 22.93749932403733 * TTp + 48.76336720791873 * TTTp -
                 45.52494862462379 * TTTTp + 15.55134951783384 * TTTTTp,
             0.24617365396517 + 0.09198001742190 * Tp - 0.57262288991447 * TTp + 1.39163022881098 * TTTp -
                 1.46948451587683 * TTTTp + 0.56164158721620 * TTTTTp,
             17.16690003784702 - 0.49770248790479 * Tp + 2.73751901890829 * TTp - 6.26973695197547 * TTTp +
                 6.36276927397430 * TTTTp - 2.37006911673031 * TTTTTp,
             110.222019291707 + 1.551579150048 * Tp - 9.701771291171 * TTp + 25.730756810615 * TTTp -
                 30.140401383522 * TTTTp + 12.796598193159 * TTTTTp,
             113.368933916592 + 9.436835192183 * Tp - 35.762300003726 * TTp + 48.966118351549 * TTTp -
                 19.384576636609 * TTTTp - 3.362714022614 * TTTTTp,
             15.17008631634665 + 137.023166578486 * Tp + 28.362805871736 * TTp - 29.677368415909 * TTTp -
                 3.585159909117 * TTTTp + 13.406844652829 * TTTTTp};
        break;
    }
    default:
        throw std::runtime_error("Unsupported planet index for MGADSM");
    }
    E[0] *= KM;
    for (int idx = 2; idx < 6; ++idx) {
        E[idx] *= RAD;
    }
    E[5] = std::fmod(E[5], 2.0 * PI);
    E[5] = m2E(E[5], E[1]);
    auto state = par2IC(E, kMuSun);
    r = state.first;
    v = state.second;
}

} // namespace mgadsm

struct Problem9Precomputed {
    Eigen::MatrixXd X;
    std::array<double, kProblem9Lines.size()> fcWeights{};
    std::array<double, kProblem9GeneratorBuses.size()> btRowSums{};
    std::array<double, kProblem9LoadBuses.size()> btColSums{};
};

const Problem9Precomputed& getProblem9Precomputed() {
    static Problem9Precomputed data = [] {
        Problem9Precomputed d;
        constexpr int nBuses = 30;
        Eigen::MatrixXd Y = Eigen::MatrixXd::Zero(nBuses, nBuses);
        for (const auto& line : kProblem9Lines) {
            const double admittance = 1.0 / line.reactance;
            const int a = line.from - 1;
            const int b = line.to - 1;
            Y(a, a) += admittance;
            Y(b, b) += admittance;
            Y(a, b) -= admittance;
            Y(b, a) -= admittance;
        }
        Eigen::MatrixXd Yred = Y.block(1, 1, nBuses - 1, nBuses - 1);
        Eigen::MatrixXd Xred = Yred.inverse();
        d.X = Eigen::MatrixXd::Zero(nBuses, nBuses);
        d.X.block(1, 1, nBuses - 1, nBuses - 1) = Xred;

        double sumReactance = 0.0;
        for (const auto& line : kProblem9Lines) {
            sumReactance += line.reactance;
        }
        for (size_t i = 0; i < kProblem9Lines.size(); ++i) {
            d.fcWeights[i] = 100.0 * kProblem9Lines[i].reactance / sumReactance;
        }

        for (size_t i = 0; i < kProblem9GeneratorBuses.size(); ++i) {
            double rowSum = 0.0;
            for (size_t j = 0; j < kProblem9LoadBuses.size(); ++j) {
                rowSum += kProblem9BT[i][j];
            }
            d.btRowSums[i] = rowSum;
        }
        for (size_t j = 0; j < kProblem9LoadBuses.size(); ++j) {
            double colSum = 0.0;
            for (size_t i = 0; i < kProblem9GeneratorBuses.size(); ++i) {
                colSum += kProblem9BT[i][j];
            }
            d.btColSums[j] = colSum;
        }
        return d;
    }();
    return data;
}

constexpr std::array<double, 6> kPgen = {0.5, 0.0, 1.65, 0.0, 0.0, 5.45};
constexpr std::array<double, 6> kPload = {0.8, 2.4, 0.4, 1.6, 2.4, 0.0};

inline double sqr(double v) { return v * v; }

double evaluateProblem1(const double *x, int nx) {
    if (nx < 6) {
        throw std::runtime_error("Problem01 expects dimension 6");
    }
    const double theta = kTwoPi / 100.0;
    double sum = 0.0;
    for (int t = 0; t <= 100; ++t) {
        const double inner = x[3] * t * theta + x[4] * std::sin(x[5] * t * theta);
        const double y_t = x[0] * std::sin(x[1] * t * theta + x[2] * std::sin(inner));
        const double y0 =
            std::sin(5.0 * t * theta - 1.5 * std::sin(4.8 * t * theta + 2.0 * std::sin(4.9 * t * theta)));
        const double diff = y_t - y0;
        sum += diff * diff;
    }
    return sum;
}

double evaluateProblem2(const double *x, int nx) {
    if (nx % 3 != 0) {
        throw std::runtime_error("Problem02 dimension must be divisible by 3");
    }
    const int n = nx / 3;
    std::vector<std::array<double, 3>> atoms(n);
    for (int i = 0; i < n; ++i) {
        atoms[i] = {x[3 * i], x[3 * i + 1], x[3 * i + 2]};
    }

    double v = 0.0;
    for (int i = 0; i < n - 1; ++i) {
        for (int j = i + 1; j < n; ++j) {
            double r2 = 0.0;
            for (int k = 0; k < 3; ++k) {
                double diff = atoms[i][k] - atoms[j][k];
                r2 += diff * diff;
            }
            const double r = std::sqrt(r2);
            if (r == 0.0) {
                continue;
            }
            const double inv_r6 = 1.0 / std::pow(r, 6.0);
            const double inv_r12 = inv_r6 * inv_r6;
            v += inv_r12 - 2.0 * inv_r6;
        }
    }
    return v;
}

double evaluateProblem3(const double *x, int nx) {
    if (nx < 1) {
        throw std::runtime_error("Problem03 expects dimension 1");
    }
    const double u = x[0];
    const auto rates = buildProblem3Rates(u);
    auto deriv = [&rates](double /*t*/, const std::array<double, 7> &state, std::array<double, 7> &dstate) {
        dstate[0] = -rates[0] * state[0];
        dstate[1] = rates[0] * state[0] - (rates[1] + rates[2]) * state[1] + rates[3] * state[4];
        dstate[2] = rates[1] * state[1];
        dstate[3] = -rates[5] * state[3] + rates[4] * state[4];
        dstate[4] = rates[2] * state[1] + rates[5] * state[3] - (rates[3] + rates[4] + rates[7] + rates[8]) * state[4] +
                    rates[6] * state[5] + rates[9] * state[6];
        dstate[5] = rates[7] * state[4] - rates[6] * state[5];
        dstate[6] = rates[8] * state[4] - rates[9] * state[6];
    };
    std::array<double, 7> state = {1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
    state = rk4Integrate(state, 0.0, 0.78, 400, deriv);
    return state[6] * 1.0e3;
}

double evaluateProblem4(const double *x, int nx) {
    if (nx < 1) {
        throw std::runtime_error("Problem04 expects dimension 1");
    }
    const double u = x[0];
    auto deriv = [u](double /*t*/, const std::array<double, 2> &state, std::array<double, 2> &dstate) {
        const double exp_term = std::exp(25.0 * state[0] / (state[0] + 2.0));
        dstate[0] = -(2.0 + u) * (state[0] + 0.25) + (state[1] + 0.5) * exp_term;
        dstate[1] = 0.5 - state[1] - (state[1] + 0.5) * exp_term;
    };
    std::array<double, 2> state = {0.09, 0.09};
    const int steps = 400;
    const double dt = 0.78 / static_cast<double>(steps);
    double cost = 0.0;
    double t = 0.0;
    for (int i = 0; i < steps; ++i) {
        cost += state[0] * state[0] + state[1] * state[1] + 0.1 * u * u;
        rk4Step(state, t, dt, deriv);
        t += dt;
    }
    return cost;
}

double evaluateTersoff(const double *x, int nx, const TersoffParams &params) {
    if (nx % 3 != 0) {
        throw std::runtime_error("Tersoff problems expect dimension multiple of 3");
    }
    const int np = nx / 3;
    std::vector<std::array<double, 3>> atoms(np);
    for (int i = 0; i < np; ++i) {
        atoms[i] = {x[3 * i], x[3 * i + 1], x[3 * i + 2]};
    }

    auto idx = [np](int i, int j) { return i * np + j; };
    std::vector<double> r(np * np, 0.0);
    std::vector<double> fcr(np * np, 0.0);
    std::vector<double> VRr(np * np, 0.0);
    std::vector<double> VAr(np * np, 0.0);

    for (int i = 0; i < np; ++i) {
        for (int j = 0; j < np; ++j) {
            if (i == j) {
                continue;
            }
            double dist2 = 0.0;
            for (int k = 0; k < 3; ++k) {
                const double diff = atoms[i][k] - atoms[j][k];
                dist2 += diff * diff;
            }
            const double dist = std::sqrt(dist2);
            r[idx(i, j)] = dist;
            double fcr_val;
            if (dist < (params.R1 - params.R2)) {
                fcr_val = 1.0;
            } else if (dist > (params.R1 + params.R2)) {
                fcr_val = 0.0;
            } else {
                fcr_val = 0.5 - 0.5 * std::sin((PI / 2.0) * (dist - params.R1) / params.R2);
            }
            fcr[idx(i, j)] = fcr_val;
            VRr[idx(i, j)] = params.A * std::exp(-params.lambda1 * dist);
            VAr[idx(i, j)] = params.B * std::exp(-params.lambda2 * dist);
        }
    }

    std::vector<double> energy(np, 0.0);
    const double lambda3_pow3 = std::pow(params.lambda3, 3.0);
    for (int i = 0; i < np; ++i) {
        for (int j = 0; j < np; ++j) {
            if (i == j) {
                continue;
            }
            double jeta = 0.0;
            for (int k = 0; k < np; ++k) {
                if (i == k || j == k) {
                    continue;
                }
                const double rd1 = r[idx(i, k)];
                const double rd3 = r[idx(k, j)];
                const double rd2 = r[idx(i, j)];
                if (rd1 == 0.0 || rd2 == 0.0) {
                    continue;
                }
                const double ctheta = (rd1 * rd1 + rd2 * rd2 - std::pow(rd3, 3.0)) / (2.0 * rd1 * rd2);
                const double G = 1.0 + std::pow(params.c, 2.0) / std::pow(params.d, 2.0) -
                                 std::pow(params.c, 2.0) / (std::pow(params.d, 2.0) + std::pow(params.h - ctheta, 2.0));
                const double exponent = lambda3_pow3 * std::pow(rd2 - rd1, 3.0);
                jeta += fcr[idx(i, k)] * G * std::exp(exponent);
            }
            const double Bij = std::pow(1.0 + std::pow(params.gamma * jeta, params.n), -0.5 / params.n);
            energy[i] += fcr[idx(i, j)] * (VRr[idx(i, j)] - Bij * VAr[idx(i, j)]) * 0.5;
        }
    }
    return std::accumulate(energy.begin(), energy.end(), 0.0);
}

double evaluateProblem7(const double *x, int nx) {
    const int d = nx;
    const int var = 2 * d - 1;
    const int total = 2 * var;
    std::vector<double> hsum(total, 0.0);
    for (int kk = 1; kk <= total; ++kk) {
        if (kk % 2 == 1) {
            const int i = (kk + 1) / 2;
            double val = 0.0;
            for (int j = i; j <= d; ++j) {
                double summ = 0.0;
                const int lower = std::abs(2 * i - j - 1) + 1;
                for (int idx = lower; idx <= j; ++idx) {
                    const int xi = std::min(std::max(idx, 1), d) - 1;
                    summ += x[xi];
                }
                val += std::cos(summ);
            }
            hsum[kk - 1] = val;
        } else {
            const int i = kk / 2;
            double val = 0.0;
            for (int j = i + 1; j <= d; ++j) {
                double summ = 0.0;
                const int lower = std::abs(2 * i - j) + 1;
                for (int idx = lower; idx <= j; ++idx) {
                    const int xi = std::min(std::max(idx, 1), d) - 1;
                    summ += x[xi];
                }
                val += std::cos(summ);
            }
            hsum[kk - 1] = val + 0.5;
        }
    }
    return *std::max_element(hsum.begin(), hsum.end());
}

double evaluateProblem8(const double *x, int nx) {
    std::vector<int> switches(nx);
    for (int i = 0; i < nx; ++i) {
        double val = std::ceil(x[i]);
        if (!std::isfinite(val)) {
            val = 1.0;
        }
        int idx = static_cast<int>(val);
        idx = std::clamp(idx, 1, static_cast<int>(kCandidateLines.size()));
        switches[i] = idx - 1;
    }

    std::vector<LineSpec> lines(kBaseLines.begin(), kBaseLines.end());
    lines.reserve(kBaseLines.size() + switches.size());
    for (int idx : switches) {
        lines.push_back(kCandidateLines[static_cast<size_t>(idx)]);
    }

    constexpr int busCount = static_cast<int>(kPgen.size());
    Eigen::MatrixXd B = Eigen::MatrixXd::Zero(busCount, busCount);
    for (const auto &line : lines) {
        const double bline = 1.0 / line.reactance;
        const int k = line.from - 1;
        const int m = line.to - 1;
        B(k, m) -= bline;
        B(m, k) = B(k, m);
        B(k, k) += bline;
        B(m, m) += bline;
    }
    B(0, 0) = 1.0e7;

    Eigen::VectorXd delP(busCount);
    for (int i = 0; i < busCount; ++i) {
        delP(i) = kPgen[i] - kPload[i];
    }

    const Eigen::VectorXd delta = B.inverse() * delP;

    std::vector<double> flows(lines.size(), 0.0);
    for (size_t idx = 0; idx < lines.size(); ++idx) {
        const auto &line = lines[idx];
        flows[idx] = (delta(line.from - 1) - delta(line.to - 1)) / line.reactance;
    }

    double cost = 30.0;
    for (size_t i = kBaseLines.size(); i < lines.size(); ++i) {
        cost += lines[i].cost;
    }

    double penalty = 0.0;
    for (size_t i = 0; i < lines.size(); ++i) {
        penalty += 5000.0 * std::max(std::abs(flows[i]) - lines[i].capacity, 0.0);
    }

    for (size_t cand = 0; cand < kCandidateLines.size(); ++cand) {
        const int count = std::count(switches.begin(), switches.end(), static_cast<int>(cand));
        if (count > 3) {
            penalty += 1000.0;
        }
    }

    return cost + penalty;
}

double evaluateProblem9(const double *x, int nx) {
    constexpr int numGenerators = static_cast<int>(kProblem9GeneratorBuses.size());
    constexpr int numLoads = static_cast<int>(kProblem9LoadBuses.size());
    constexpr int numLines = static_cast<int>(kProblem9Lines.size());
    const int expectedDim = numGenerators * numLoads;
    if (nx != expectedDim) {
        throw std::runtime_error("Problem09 expects dimension 126.");
    }

    const auto &pre = getProblem9Precomputed();
    const auto ptdfIndex = [numLoads, numLines](int i, int j, int k) {
        return (i * numLoads + j) * numLines + k;
    };

    std::vector<double> gd(expectedDim);
    for (int idx = 0; idx < expectedDim; ++idx) {
        gd[idx] = x[idx];
    }

    std::vector<double> ptdf(expectedDim * numLines);
    for (int i = 0; i < numGenerators; ++i) {
        const int gBus = kProblem9GeneratorBuses[i] - 1;
        for (int j = 0; j < numLoads; ++j) {
            const int dBus = kProblem9LoadBuses[j] - 1;
            for (int k = 0; k < numLines; ++k) {
                const int from = kProblem9Lines[k].from - 1;
                const int to = kProblem9Lines[k].to - 1;
                const double numerator = pre.X(from, gBus) - pre.X(to, gBus) - pre.X(from, dBus) + pre.X(to, dBus);
                ptdf[ptdfIndex(i, j, k)] = numerator / kProblem9Lines[k].reactance;
            }
        }
    }

    std::vector<double> flows(numLines, 0.0);
    for (int i = 0; i < numGenerators; ++i) {
        for (int j = 0; j < numLoads; ++j) {
            const double gdVal = gd[i * numLoads + j];
            const double btVal = kProblem9BT[i][j];
            for (int k = 0; k < numLines; ++k) {
                const double absPtdf = std::abs(ptdf[ptdfIndex(i, j, k)]);
                flows[k] += absPtdf * (std::abs(gdVal) + std::abs(btVal));
            }
        }
    }

    std::array<double, numLines> costLine{};
    for (int k = 0; k < numLines; ++k) {
        const double denom = std::max(flows[k], 1e-12);
        costLine[k] = pre.fcWeights[k] / denom;
    }

    std::vector<double> costL(expectedDim, 0.0);
    std::array<double, numGenerators> costGen{};
    costGen.fill(0.0);
    for (int i = 0; i < numGenerators; ++i) {
        for (int j = 0; j < numLoads; ++j) {
            double sum = 0.0;
            for (int k = 0; k < numLines; ++k) {
                sum += std::abs(costLine[k] * ptdf[ptdfIndex(i, j, k)]);
            }
            costL[i * numLoads + j] = sum;
            costGen[i] += gd[i * numLoads + j] * sum;
        }
    }

    double rateEbe1 = 0.0;
    for (int i = 0; i < numGenerators; ++i) {
        const double pgAvailable = std::max(kProblem9Pg[i] - pre.btRowSums[i], 1e-12);
        const double ratio = costGen[i] / pgAvailable;
        rateEbe1 += sqr(ratio - kProblem9Rg[i]);
    }

    double rateEbe2 = 0.0;
    for (int j = 0; j < numLoads; ++j) {
        double sum = 0.0;
        for (int i = 0; i < numGenerators; ++i) {
            sum += gd[i * numLoads + j] * costL[i * numLoads + j];
        }
        const double pdAvailable = std::max(kProblem9Pd[j] - pre.btColSums[j], 1e-12);
        const double ratio = sum / pdAvailable;
        rateEbe2 += sqr(ratio - kProblem9Rd[j]);
    }

    const double rate_d = rateEbe1 + rateEbe2;

    std::array<double, numGenerators> rowSum{};
    std::array<double, numLoads> colSum{};
    rowSum.fill(0.0);
    colSum.fill(0.0);
    for (int i = 0; i < numGenerators; ++i) {
        for (int j = 0; j < numLoads; ++j) {
            const double val = gd[i * numLoads + j];
            rowSum[i] += val;
            colSum[j] += val;
        }
    }

    double gpen = 0.0;
    for (int i = 0; i < numGenerators; ++i) {
        const double pgx = rowSum[i] + pre.btRowSums[i];
        gpen += 100.0 * std::abs(pgx - kProblem9Pg[i]);
    }
    double ldpen = 0.0;
    for (int j = 0; j < numLoads; ++j) {
        const double pdx = colSum[j] + pre.btColSums[j];
        ldpen += 100.0 * std::abs(pdx - kProblem9Pd[j]);
    }

    constexpr double Kp = 100.0;
    const double penalty = gpen + ldpen;
    return rate_d + 50.0 * Kp * penalty;
}

double arrayFactorCircular(const double *x, int dim, double phiRad, double phiDesiredDeg, double spacing) {
    const int half = dim / 2;
    const double phiDesiredRad = phiDesiredDeg * PI / 180.0;
    double realSum = 0.0;
    double imagSum = 0.0;

    for (int i = 0; i < half; ++i) {
        const double delphi = 2.0 * PI * static_cast<double>(i) / dim;
        const double shi = (std::cos(phiRad - delphi) - std::cos(phiDesiredRad - delphi)) * dim * spacing;
        const double amplitude = x[i];
        const double phase = x[half + i] * PI / 180.0;
        realSum += amplitude * std::cos(shi + phase);
        imagSum += amplitude * std::sin(shi + phase);
    }
    for (int i = half; i < dim; ++i) {
        const double delphi = 2.0 * PI * static_cast<double>(i) / dim;
        const double shi = (std::cos(phiRad - delphi) - std::cos(phiDesiredRad - delphi)) * dim * spacing;
        const double amplitude = x[i - half];
        const double phase = x[i] * PI / 180.0;
        realSum += amplitude * std::cos(shi - phase);
        imagSum += amplitude * std::sin(shi - phase);
    }
    return std::sqrt(realSum * realSum + imagSum * imagSum);
}

double trapezoidalCircular(const double *x, int dim, double lower, double upper, int segments,
                           double phiDesiredDeg, double spacing) {
    const double h = (upper - lower) / static_cast<double>(segments);
    double sum = 0.0;
    for (int i = 0; i <= segments; ++i) {
        const double phi = lower + h * i;
        const double af = arrayFactorCircular(x, dim, phi, phiDesiredDeg, spacing);
        const double value = std::abs(af * af * std::sin(phi - PI / 2.0));
        if (i == 0 || i == segments) {
            sum += value;
        } else {
            sum += 2.0 * value;
        }
    }
    return (h / 2.0) * sum;
}

double evaluateProblem10(const double *x, int nx) {
    constexpr int dim = 12;
    if (nx != dim) {
        throw std::runtime_error("Problem10 expects dimension 12.");
    }

    constexpr int numSamples = 300;
    std::array<double, numSamples> phiDeg{};
    const double step = 360.0 / static_cast<double>(numSamples - 1);
    for (int i = 0; i < numSamples; ++i) {
        phiDeg[i] = step * i;
    }

    std::array<double, numSamples> yax{};
    double maxi = arrayFactorCircular(x, dim, phiDeg[0] * PI / 180.0, kProblem10PhiDesired, kProblem10Spacing);
    yax[0] = maxi;
    double phiZero = phiDeg[0];
    int phiRef = 0;
    for (int i = 1; i < numSamples; ++i) {
        const double val = arrayFactorCircular(x, dim, phiDeg[i] * PI / 180.0, kProblem10PhiDesired, kProblem10Spacing);
        yax[i] = val;
        if (val > maxi) {
            maxi = val;
            phiZero = phiDeg[i];
            phiRef = i;
        }
    }
    const double maxGuard = std::max(maxi, 1e-12);

    std::vector<double> sidelobes;
    if (yax[0] > yax[numSamples - 1] && yax[0] > yax[1]) {
        sidelobes.push_back(yax[0]);
    }
    if (yax[numSamples - 1] > yax[0] && yax[numSamples - 1] > yax[numSamples - 2]) {
        sidelobes.push_back(yax[numSamples - 1]);
    }
    for (int i = 1; i < numSamples - 1; ++i) {
        if (yax[i] > yax[i - 1] && yax[i] > yax[i + 1]) {
            sidelobes.push_back(yax[i]);
        }
    }
    std::sort(sidelobes.begin(), sidelobes.end(), std::greater<double>());
    double sllreturn = 0.0;
    if (sidelobes.size() >= 2) {
        sllreturn = 20.0 * std::log10(std::max(sidelobes[1], 1e-12) / maxGuard);
    }

    double upperBound = 180.0;
    for (int offset = 1; offset < numSamples / 2; ++offset) {
        const int idx = phiRef + offset;
        if (idx >= numSamples - 1) {
            break;
        }
        if (yax[idx] < yax[idx - 1] && yax[idx] < yax[idx + 1]) {
            upperBound = phiDeg[idx] - phiDeg[phiRef];
            break;
        }
    }
    double lowerBound = 180.0;
    for (int offset = 1; offset < numSamples / 2; ++offset) {
        const int idx = phiRef - offset;
        if (idx <= 0) {
            break;
        }
        if (yax[idx] < yax[idx - 1] && yax[idx] < yax[idx + 1]) {
            lowerBound = phiDeg[phiRef] - phiDeg[idx];
            break;
        }
    }
    const double bwfn = upperBound + lowerBound;

    double nullPenalty = 0.0;
    for (double nullAngle : kProblem10NullAngles) {
        const double val = arrayFactorCircular(x, dim, nullAngle, kProblem10PhiDesired, kProblem10Spacing);
        nullPenalty += val / maxGuard;
    }

    const double uavg = trapezoidalCircular(x, dim, 0.0, 2.0 * PI, 50, kProblem10PhiDesired, kProblem10Spacing);
    const double y2 = std::abs(2.0 * PI * maxGuard * maxGuard / std::max(uavg, 1e-12));
    const double directivity = 10.0 * std::log10(std::max(y2, 1e-12));
    (void)directivity;

    double y3 = std::abs(phiZero - kProblem10PhiDesired);
    if (y3 < 5.0) {
        y3 = 0.0;
    }

    double penalty = 0.0;
    if (bwfn > 80.0) {
        penalty += std::abs(bwfn - 80.0);
    }

    return sllreturn + penalty + nullPenalty + y3;
}

const DEDProblem &getDED5() {
    static const DEDProblem problem = [] {
        DEDProblem prob;
        prob.units = 5;
        prob.hours = 24;
        prob.demand = {410, 435, 475, 530, 558, 608, 626, 654, 690, 704, 720, 740,
                       704, 690, 654, 580, 558, 608, 654, 704, 680, 605, 527, 463};
        const double data1[][7] = {
            {10, 75, 0.0080, 2.0, 25, 100, 0.042},
            {20, 125, 0.0030, 1.8, 60, 140, 0.040},
            {30, 175, 0.0012, 2.1, 100, 160, 0.038},
            {40, 250, 0.0010, 2.0, 120, 180, 0.037},
            {50, 300, 0.0015, 1.8, 40, 200, 0.035}};
        const double data2[][7] = {
            {0, 30, 30, 10, 10, 10, 10},
            {0, 30, 30, 20, 20, 20, 20},
            {0, 40, 40, 30, 30, 30, 30},
            {0, 50, 50, 40, 40, 40, 40},
            {0, 50, 50, 50, 50, 50, 50}};
        prob.unitData.resize(prob.units);
        for (int i = 0; i < prob.units; ++i) {
            UnitData unit;
            unit.pmin = data1[i][0];
            unit.pmax = data1[i][1];
            unit.a = data1[i][2];
            unit.b = data1[i][3];
            unit.c = data1[i][4];
            unit.e = data1[i][5];
            unit.f = data1[i][6];
            unit.upRamp = data2[i][1];
            unit.downRamp = data2[i][2];
            unit.initial = std::numeric_limits<double>::quiet_NaN();
            for (int z = 3; z + 1 < 7; z += 2) {
                const double lower = data2[i][z];
                const double upper = data2[i][z + 1];
                if (upper > lower) {
                    unit.zones.push_back({lower, upper});
                }
            }
            prob.unitData[i] = unit;
        }
        const double b1[][5] = {
            {0.000049, 0.000014, 0.000015, 0.000015, 0.000020},
            {0.000014, 0.000045, 0.000016, 0.000020, 0.000018},
            {0.000015, 0.000016, 0.000039, 0.000010, 0.000012},
            {0.000015, 0.000020, 0.000010, 0.000040, 0.000014},
            {0.000020, 0.000018, 0.000012, 0.000014, 0.000035}};
        prob.loss.B1.resize(prob.units * prob.units);
        for (int i = 0; i < prob.units; ++i) {
            for (int j = 0; j < prob.units; ++j) {
                prob.loss.B1[i * prob.units + j] = b1[i][j];
            }
        }
        prob.loss.B2.assign(prob.units, 0.0);
        prob.loss.B3 = 0.0;
        prob.penaltyBalance = 1e3;
        prob.penaltyCapacity = 1e3;
        prob.penaltyRamp = 1e5;
        prob.penaltyPoz = 1e5;
        prob.roundLoss = true;
        return prob;
    }();
    return problem;
}

const DEDProblem &getDED10() {
    static const DEDProblem problem = [] {
        DEDProblem prob;
        prob.units = 10;
        prob.hours = 24;
        prob.demand = {1036, 1110, 1258, 1406, 1480, 1628, 1702, 1776, 1924, 2072, 2146, 2220,
                       2072, 1924, 1776, 1554, 1480, 1628, 1776, 2072, 1924, 1628, 1332, 1184};
        const double data1[][7] = {
            {150, 470, 0.00043, 21.60, 958.20, 450, 0.041},
            {135, 460, 0.00063, 21.05, 1313.6, 600, 0.036},
            {73, 340, 0.00039, 20.81, 604.97, 320, 0.028},
            {60, 300, 0.00070, 23.90, 471.60, 260, 0.052},
            {73, 243, 0.00079, 21.62, 480.29, 280, 0.063},
            {57, 160, 0.00056, 17.87, 601.75, 310, 0.048},
            {20, 130, 0.00211, 16.51, 502.7, 300, 0.086},
            {47, 120, 0.0048, 23.23, 639.40, 340, 0.082},
            {20, 80, 0.10908, 19.58, 455.60, 270, 0.098},
            {55, 55, 0.00951, 22.54, 692.4, 380, 0.094}};
        const double data2[][3] = {
            {0, 80, 80}, {0, 80, 80}, {0, 80, 80}, {0, 50, 50}, {0, 50, 50},
            {0, 50, 50}, {0, 30, 30}, {0, 30, 30}, {0, 30, 30}, {0, 30, 30}};
        prob.unitData.resize(prob.units);
        for (int i = 0; i < prob.units; ++i) {
            UnitData unit;
            unit.pmin = data1[i][0];
            unit.pmax = data1[i][1];
            unit.a = data1[i][2];
            unit.b = data1[i][3];
            unit.c = data1[i][4];
            unit.e = data1[i][5];
            unit.f = data1[i][6];
            unit.upRamp = data2[i][1];
            unit.downRamp = data2[i][2];
            unit.initial = std::numeric_limits<double>::quiet_NaN();
            prob.unitData[i] = unit;
        }
        prob.loss.B1.assign(prob.units * prob.units, 0.0);
        prob.loss.B2.assign(prob.units, 0.0);
        prob.loss.B3 = 0.0;
        prob.penaltyBalance = 1e3;
        prob.penaltyCapacity = 1e3;
        prob.penaltyRamp = 1e3;
        prob.penaltyPoz = 1e5;
        prob.roundLoss = false;
        return prob;
    }();
    return problem;
}

const ELDProblem &getELD6() {
    static const ELDProblem problem = [] {
        ELDProblem prob;
        prob.units = 6;
        prob.demand = 1263.0;
        const double data1[][5] = {
            {100, 500, 0.0070, 7.0, 240},
            {50, 200, 0.0095, 10.0, 200},
            {80, 300, 0.0090, 8.5, 220},
            {50, 150, 0.0090, 11.0, 200},
            {50, 200, 0.0080, 10.5, 220},
            {50, 120, 0.0075, 12.0, 190}};
        const double data2[][7] = {
            {440, 80, 120, 210, 240, 350, 380},
            {170, 50, 90, 90, 110, 140, 160},
            {200, 65, 100, 150, 170, 210, 240},
            {150, 50, 90, 80, 90, 110, 120},
            {190, 50, 90, 90, 110, 140, 150},
            {150, 50, 90, 75, 85, 100, 105}};
        prob.unitData.resize(prob.units);
        for (int i = 0; i < prob.units; ++i) {
            UnitData unit{};
            unit.pmin = data1[i][0];
            unit.pmax = data1[i][1];
            unit.a = data1[i][2];
            unit.b = data1[i][3];
            unit.c = data1[i][4];
            unit.e = 0.0;
            unit.f = 0.0;
            unit.initial = data2[i][0];
            unit.upRamp = data2[i][1];
            unit.downRamp = data2[i][2];
            for (int z = 3; z + 1 < 7; z += 2) {
                const double lower = data2[i][z];
                const double upper = data2[i][z + 1];
                if (upper > lower) {
                    unit.zones.push_back({lower, upper});
                }
            }
            prob.unitData[i] = unit;
        }
        const double b1Base[][6] = {
            {1.7, 1.2, 0.7, -0.1, -0.5, -0.2},
            {1.2, 1.4, 0.9, 0.1, -0.6, -0.1},
            {0.7, 0.9, 3.1, 0.0, -1.0, -0.6},
            {-0.1, 0.1, 0.0, 0.24, -0.6, -0.8},
            {-0.5, -0.6, -0.1, -0.6, 12.9, -0.2},
            {0.2, -0.1, -0.6, -0.8, -0.2, 15.0}};
        prob.loss.B1.resize(prob.units * prob.units);
        for (int i = 0; i < prob.units; ++i) {
            for (int j = 0; j < prob.units; ++j) {
                prob.loss.B1[i * prob.units + j] = b1Base[i][j] * 1e-5;
            }
        }
        const double b2Base[] = {-0.3908, -0.1297, 0.7047, 0.0591, 0.2161, -0.6635};
        prob.loss.B2.resize(prob.units);
        for (int i = 0; i < prob.units; ++i) {
            prob.loss.B2[i] = b2Base[i] * 1e-5;
        }
        prob.loss.B3 = 0.0056 * 1e-2;
        prob.penaltyBalance = 1e3;
        prob.penaltyCapacity = 1e3;
        prob.penaltyRamp = 1e5;
        prob.penaltyPoz = 1e5;
        prob.roundLoss = true;
        return prob;
    }();
    return problem;
}

const ELDProblem &getELD13() {
    static const ELDProblem problem = [] {
        ELDProblem prob;
        prob.units = 13;
        prob.demand = 1800.0;
        prob.unitData.resize(prob.units);
        for (int i = 0; i < prob.units; ++i) {
            const auto &row = kELD13Data1[i];
            UnitData unit{};
            unit.pmin = row[0];
            unit.pmax = row[1];
            unit.a = row[2];
            unit.b = row[3];
            unit.c = row[4];
            unit.e = row[5];
            unit.f = row[6];
            unit.initial = std::numeric_limits<double>::quiet_NaN();
            unit.upRamp = 0.0;
            unit.downRamp = 0.0;
            prob.unitData[i] = unit;
        }
        prob.loss.B1.assign(prob.units * prob.units, 0.0);
        prob.loss.B2.assign(prob.units, 0.0);
        prob.loss.B3 = 0.0;
        prob.penaltyBalance = 1e5;
        prob.penaltyCapacity = 1e3;
        prob.penaltyRamp = 0.0;
        prob.penaltyPoz = 0.0;
        prob.roundLoss = true;
        return prob;
    }();
    return problem;
}

const ELDProblem &getELD15() {
    static const ELDProblem problem = [] {
        ELDProblem prob;
        prob.units = 15;
        prob.demand = 2630.0;
        prob.unitData.resize(prob.units);
        for (int i = 0; i < prob.units; ++i) {
            const auto &row = kELD15Data1[i];
            UnitData unit{};
            unit.pmin = row[0];
            unit.pmax = row[1];
            unit.a = row[2];
            unit.b = row[3];
            unit.c = row[4];
            unit.e = 0.0;
            unit.f = 0.0;
            unit.initial = kELD15Data2[i][0];
            unit.upRamp = kELD15Data2[i][1];
            unit.downRamp = kELD15Data2[i][2];
            for (int z = 3; z + 1 < 9; z += 2) {
                const double lower = kELD15Data2[i][z];
                const double upper = kELD15Data2[i][z + 1];
                if (upper > lower) {
                    unit.zones.push_back({lower, upper});
                }
            }
            prob.unitData[i] = unit;
        }
        prob.loss.B1.resize(prob.units * prob.units);
        for (int i = 0; i < prob.units; ++i) {
            for (int j = 0; j < prob.units; ++j) {
                prob.loss.B1[i * prob.units + j] = kELD15B1[i][j] * 1e-5;
            }
        }
        prob.loss.B2.resize(prob.units);
        for (int i = 0; i < prob.units; ++i) {
            prob.loss.B2[i] = kELD15B2[i];
        }
        prob.loss.B3 = 0.0055e-2;
        prob.penaltyBalance = 1e3;
        prob.penaltyCapacity = 1e3;
        prob.penaltyRamp = 1e5;
        prob.penaltyPoz = 1e5;
        prob.roundLoss = true;
        return prob;
    }();
    return problem;
}

const ELDProblem &getELD40() {
    static const ELDProblem problem = [] {
        ELDProblem prob;
        prob.units = 40;
        prob.demand = 10500.0;
        prob.unitData.resize(prob.units);
        for (int i = 0; i < prob.units; ++i) {
            const auto &row = kELD40Data1[i];
            UnitData unit{};
            unit.pmin = row[0];
            unit.pmax = row[1];
            unit.a = row[2];
            unit.b = row[3];
            unit.c = row[4];
            unit.e = row[5];
            unit.f = row[6];
            unit.initial = std::numeric_limits<double>::quiet_NaN();
            unit.upRamp = 0.0;
            unit.downRamp = 0.0;
            prob.unitData[i] = unit;
        }
        prob.loss.B1.assign(prob.units * prob.units, 0.0);
        prob.loss.B2.assign(prob.units, 0.0);
        prob.loss.B3 = 0.0;
        prob.penaltyBalance = 1e5;
        prob.penaltyCapacity = 1e3;
        prob.penaltyRamp = 0.0;
        prob.penaltyPoz = 0.0;
        prob.roundLoss = true;
        return prob;
    }();
    return problem;
}

const ELDProblem &getELD140() {
    static const ELDProblem problem = [] {
        ELDProblem prob;
        prob.units = 140;
        prob.demand = 49342.0;
        prob.unitData.resize(prob.units);
        for (int i = 0; i < prob.units; ++i) {
            const auto &row = kELD140Data1[i];
            UnitData unit{};
            unit.pmin = row[0];
            unit.pmax = row[1];
            unit.c = row[2];
            unit.b = row[3];
            unit.a = row[4];
            unit.e = 0.0;
            unit.f = 0.0;
            unit.initial = kELD140Data2[i][0];
            unit.upRamp = kELD140Data2[i][1];
            unit.downRamp = kELD140Data2[i][2];
            prob.unitData[i] = unit;
        }
        for (const auto &row : kELD140Poz) {
            const int idx = static_cast<int>(row[0]) - 1;
            if (idx < 0 || idx >= prob.units) {
                continue;
            }
            for (int c = 1; c + 1 < 7; c += 2) {
                const double lower = row[c];
                const double upper = row[c + 1];
                if (upper > lower) {
                    prob.unitData[idx].zones.push_back({lower, upper});
                }
            }
        }
        prob.loss.B1.assign(prob.units * prob.units, 0.0);
        prob.loss.B2.assign(prob.units, 0.0);
        prob.loss.B3 = 0.0;
        prob.penaltyBalance = 1e7;
        prob.penaltyCapacity = 1e5;
        prob.penaltyRamp = 1e7;
        prob.penaltyPoz = 1e5;
        prob.roundLoss = true;
        return prob;
    }();
    return problem;
}

HydroThermalProblem buildHydroThermalProblem(double pozWeight, bool includePozZones, bool valvePoint) {
    HydroThermalProblem prob;
    prob.units = kHydroUnits;
    prob.hours = kHydroHours;
    prob.ptMin = 500.0;
    prob.ptMax = 2500.0;
    prob.demand.assign(kHydroDemand.begin(), kHydroDemand.end());
    prob.weights = kHydroBaseWeights;
    prob.weights.poz = pozWeight;
    prob.valvePoint = valvePoint;
    prob.unitData.resize(kHydroUnits);
    for (int i = 0; i < kHydroUnits; ++i) {
        HydroUnitSpec unit{};
        unit.qmin = kHydroQmin[i];
        unit.qmax = kHydroQmax[i];
        unit.phMin = kHydroPhMin[i];
        unit.phMax = kHydroPhMax[i];
        unit.vmin = kHydroVmin[i];
        unit.vmax = kHydroVmax[i];
        unit.vInitial = kHydroVInitial[i];
        unit.vFinal = kHydroVFinal[i];
        unit.delay = kHydroDelay[i];
        unit.upstreamCount = kHydroUpstream[i];
        unit.coeffs = kHydroCoefficients[i];
        unit.inflow.assign(kHydroInflows[i].begin(), kHydroInflows[i].end());
        if (includePozZones) {
            const double lower = kHydroPozBounds[i][0];
            const double upper = kHydroPozBounds[i][1];
            if (upper > lower) {
                unit.poz.push_back({lower, upper});
            }
        }
        prob.unitData[i] = unit;
    }
    return prob;
}

const HydroThermalProblem &getHydroThermalCase1() {
    static const HydroThermalProblem problem = buildHydroThermalProblem(0.0, false, false);
    return problem;
}

const HydroThermalProblem &getHydroThermalCase2() {
    static const HydroThermalProblem problem = buildHydroThermalProblem(1e5, true, false);
    return problem;
}

const HydroThermalProblem &getHydroThermalCase3() {
    static const HydroThermalProblem problem = buildHydroThermalProblem(0.0, true, true);
    return problem;
}

const MGADSMProblem &getMessengerFull() {
    static const MGADSMProblem problem = [] {
        MGADSMProblem prob;
        prob.sequence = {3, 2, 2, 1, 1, 1, 1};
        prob.objective = MGADSMObjectiveType::OrbitInsertion;
        prob.rpTarget = 2640.0;
        prob.eTarget = 0.704;
        return prob;
    }();
    return problem;
}

const MGADSMProblem &getCassini2() {
    static const MGADSMProblem problem = [] {
        MGADSMProblem prob;
        prob.sequence = {3, 2, 2, 3, 5, 6};
        prob.objective = MGADSMObjectiveType::TotalDVRendezvous;
        prob.rpTarget = 0.0;
        prob.eTarget = 0.0;
        return prob;
    }();
    return problem;
}

} // namespace

namespace CEC2011 {

void evaluate(double *x, double *f, int nx, int mx, int func_num) {
    for (int i = 0; i < mx; ++i) {
        const double *xi = x + i * nx;
        switch (func_num) {
        case 1:
            f[i] = evaluateProblem1(xi, nx);
            break;
        case 2:
            f[i] = evaluateProblem2(xi, nx);
            break;
        case 3:
            f[i] = evaluateProblem3(xi, nx);
            break;
        case 4:
            f[i] = evaluateProblem4(xi, nx);
            break;
        case 5:
            f[i] = evaluateTersoff(xi, nx, kProblem5Params);
            break;
        case 6:
            f[i] = evaluateTersoff(xi, nx, kProblem6Params);
            break;
        case 7:
            f[i] = evaluateProblem7(xi, nx);
            break;
        case 8:
            f[i] = evaluateProblem8(xi, nx);
            break;
        case 9:
            f[i] = evaluateProblem9(xi, nx);
            break;
        case 10:
            f[i] = evaluateProblem10(xi, nx);
            break;
        case 11:
            f[i] = evaluateDED(xi, nx, getDED5());
            break;
        case 12:
            f[i] = evaluateDED(xi, nx, getDED10());
            break;
        case 13:
            f[i] = evaluateELD(xi, nx, getELD6());
            break;
        case 14:
            f[i] = evaluateELD(xi, nx, getELD13());
            break;
        case 15:
            f[i] = evaluateELD(xi, nx, getELD15());
            break;
        case 16:
            f[i] = evaluateELD(xi, nx, getELD40());
            break;
        case 17:
            f[i] = evaluateELD(xi, nx, getELD140());
            break;
        case 18:
            f[i] = evaluateHydroThermal(xi, nx, getHydroThermalCase1());
            break;
        case 19:
            f[i] = evaluateHydroThermal(xi, nx, getHydroThermalCase2());
            break;
        case 20:
            f[i] = evaluateHydroThermal(xi, nx, getHydroThermalCase3());
            break;
        case 21:
            f[i] = mgadsm::evaluate(xi, nx, getMessengerFull());
            break;
        case 22:
            f[i] = mgadsm::evaluate(xi, nx, getCassini2());
            break;
        default:
            throw std::runtime_error("CEC2011 function not implemented yet");
        }
    }
}

} // namespace CEC2011

} // namespace minion
